{
  "version": 3,
  "sources": ["../../.deno/kute.js@2.2.4/node_modules/kute.js/dist/kute.esm.js"],
  "sourcesContent": ["/*!\n* KUTE.js Standard v2.2.4 (http://thednp.github.io/kute.js)\n* Copyright 2015-2022 Â© thednp\n* Licensed under MIT (https://github.com/thednp/kute.js/blob/master/LICENSE)\n*/\n/**\r\n * Creates cubic-bezier easing functions for animation engines.\r\n * @see http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h\r\n * \r\n *\r\n * @class\r\n */\r\nclass CubicBezier {\r\n  /**\r\n   * @constructor\r\n   * @param {number} x1 - first point horizontal position\r\n   * @param {number} y1 - first point vertical position\r\n   * @param {number} x2 - second point horizontal position\r\n   * @param {number} y2 - second point vertical position\r\n   * @param {string=} functionName - an optional function name\r\n   * @returns {(t: number) => number} a new CubicBezier easing function\r\n   */\r\n  constructor(x1, y1, x2, y2, functionName) {\r\n    // pre-calculate the polynomial coefficients\r\n    // First and last control points are implied to be (0.0, 0.0) and (1.0, 1.0)\r\n    const p1x = x1 || 0;\r\n    const p1y = y1 || 0;\r\n    const p2x = x2 || 1;\r\n    const p2y = y2 || 1;\r\n  \r\n    /** @type {number} */\r\n    this.cx = 3 * p1x;\r\n  \r\n    /** @type {number} */\r\n    this.bx = 3 * (p2x - p1x) - this.cx;\r\n\r\n    /** @type {number} */\r\n    this.ax = 1 - this.cx - this.bx;\r\n    \r\n    /** @type {number} */\r\n    this.cy = 3 * p1y;\r\n  \r\n    /** @type {number} */\r\n    this.by = 3 * (p2y - p1y) - this.cy;\r\n  \r\n    /** @type {number} */\r\n    this.ay = 1 - this.cy - this.by;\r\n    \r\n    /** @type {(t: number) => number} */\r\n    const BezierEasing = (t) => this.sampleCurveY(this.solveCurveX(t));\r\n\r\n    // this function needs a name\r\n    Object.defineProperty(BezierEasing, 'name', { writable: true });\r\n    BezierEasing.name = functionName || `cubic-bezier(${[p1x, p1y, p2x, p2y]})`;\r\n\r\n    return BezierEasing;\r\n  }\r\n\r\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled X value\r\n   */\r\n  sampleCurveX(t) {\r\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\r\n  }\r\n\r\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled Y value\r\n   */\r\n  sampleCurveY(t) {\r\n    return ((this.ay * t + this.by) * t + this.cy) * t;\r\n  }\r\n\r\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled curve derivative X value\r\n   */\r\n  sampleCurveDerivativeX(t) {\r\n    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x - progress [0-1]\r\n   * @return {number} - solved curve X value\r\n   */\r\n  solveCurveX(x) {\r\n    // Set Precision\r\n    const epsilon = 1e-6;\r\n\r\n    // Skip values out of range\r\n    if (x <= 0) return 0;\r\n    if (x >= 1) return 1;\r\n\r\n    let t2 = x;\r\n    let x2 = 0;\r\n    let d2 = 0;\r\n\r\n    // First try a few iterations of Newton's method\r\n    // -- usually very fast.\r\n    for (let i = 0; i < 8; i += 1) {\r\n      x2 = this.sampleCurveX(t2) - x;\r\n      if (Math.abs(x2) < epsilon) return t2;\r\n      d2 = this.sampleCurveDerivativeX(t2);\r\n      /* istanbul ignore next */\r\n      if (Math.abs(d2) < epsilon) break;\r\n      t2 -= x2 / d2;\r\n    }\r\n\r\n    // No solution found - use bi-section\r\n    let t0 = 0;\r\n    let t1 = 1;\r\n    t2 = x;\r\n\r\n    while (t0 < t1) {\r\n      x2 = this.sampleCurveX(t2);\r\n      if (Math.abs(x2 - x) < epsilon) return t2;\r\n      if (x > x2) t0 = t2;\r\n      else t1 = t2;\r\n\r\n      t2 = (t1 - t0) * 0.5 + t0;\r\n    }\r\n\r\n    // Give up\r\n    /* istanbul ignore next */\r\n    return t2;\r\n  }\r\n}\n\nvar version$1 = \"1.0.1\";\n\n/**\r\n * A global namespace for library version.\r\n * @type {string}\r\n */\r\nconst Version$1 = version$1;\n\n/** @typedef {import('../types/index')} */\r\n\r\nObject.assign(CubicBezier, { Version: Version$1 });\n\n/**\n * The KUTE.js Execution Context\n */\nconst KEC = {};\n\nconst Tweens = [];\n\nlet gl0bal;\n\nif (typeof global !== 'undefined') gl0bal = global;\nelse if (typeof window !== 'undefined') gl0bal = window.self;\nelse gl0bal = {};\n\nconst globalObject = gl0bal;\n\n// KUTE.js INTERPOLATE FUNCTIONS\n// =============================\nconst interpolate = {};\n\n// schedule property specific function on animation start\n// link property update function to KUTE.js execution context\nconst onStart = {};\n\n// Include a performance.now polyfill.\n// source https://github.com/tweenjs/tween.js/blob/master/src/Now.ts\nlet performanceNow;\n\n// In node.js, use process.hrtime.\n// eslint-disable-next-line\n// @ts-ignore\r\nif (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {\n  performanceNow = () => {\n    // eslint-disable-next-line\n\t\t// @ts-ignore\r\n    const time = process.hrtime();\n\n    // Convert [seconds, nanoseconds] to milliseconds.\n    return time[0] * 1000 + time[1] / 1000000;\n  };\n} else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {\n  // In a browser, use self.performance.now if it is available.\n  // This must be bound, because directly assigning this function\n  // leads to an invocation exception in Chrome.\n  performanceNow = self.performance.now.bind(self.performance);\n} else if (typeof Date !== 'undefined' && Date.now) {\n  // Use Date.now if it is available.\n  performanceNow = Date.now;\n} else {\n  // Otherwise, use 'new Date().getTime()'.\n  performanceNow = () => new Date().getTime();\n}\n\nconst now = performanceNow;\n\nconst Time = {};\nTime.now = now;\n\n// eslint-disable-next-line import/no-mutable-exports -- impossible to satisfy\nlet Tick = 0;\n\n/**\n *\n * @param {number | Date} time\n */\nconst Ticker = (time) => {\n  let i = 0;\n  while (i < Tweens.length) {\n    if (Tweens[i].update(time)) {\n      i += 1;\n    } else {\n      Tweens.splice(i, 1);\n    }\n  }\n  Tick = requestAnimationFrame(Ticker);\n};\n\n// stop requesting animation frame\nfunction stop() {\n  setTimeout(() => { // re-added for #81\n    if (!Tweens.length && Tick) {\n      cancelAnimationFrame(Tick);\n      Tick = null;\n      Object.keys(onStart).forEach((obj) => {\n        if (typeof (onStart[obj]) === 'function') {\n          if (KEC[obj]) delete KEC[obj];\n        } else {\n          Object.keys(onStart[obj]).forEach((prop) => {\n            if (KEC[prop]) delete KEC[prop];\n          });\n        }\n      });\n\n      Object.keys(interpolate).forEach((i) => {\n        if (KEC[i]) delete KEC[i];\n      });\n    }\n  }, 64);\n}\n\n// render update functions\n// =======================\nconst Render = {\n  Tick, Ticker, Tweens, Time,\n};\nObject.keys(Render).forEach((blob) => {\n  if (!KEC[blob]) {\n    KEC[blob] = blob === 'Time' ? Time.now : Render[blob];\n  }\n});\n\nglobalObject._KUTE = KEC;\n\n// all supported properties\nconst supportedProperties = {};\n\nconst defaultValues = {};\n\nconst defaultOptions$1 = {\n  duration: 700,\n  delay: 0,\n  easing: 'linear',\n  repeat: 0,\n  repeatDelay: 0,\n  yoyo: false,\n  resetStart: false,\n  offset: 0,\n};\n\n// used in preparePropertiesObject\nconst prepareProperty = {};\n\n// check current property value when .to() method is used\nconst prepareStart = {};\n\n// checks for differences between the processed start and end values,\n// can be set to make sure start unit and end unit are same,\n// stack transforms, process SVG paths,\n// any type of post processing the component needs\nconst crossCheck = {};\n\n// schedule property specific function on animation complete\nconst onComplete = {};\n\n// link properties to interpolate functions\nconst linkProperty = {};\n\nconst Objects = {\n  supportedProperties,\n  defaultValues,\n  defaultOptions: defaultOptions$1,\n  prepareProperty,\n  prepareStart,\n  crossCheck,\n  onStart,\n  onComplete,\n  linkProperty,\n};\n\n// util - a general object for utils like rgbToHex, processEasing\nconst Util = {};\n\n/**\n * KUTE.add(Tween)\n *\n * @param {KUTE.Tween} tw a new tween to add\n */\nconst add = (tw) => Tweens.push(tw);\n\n/**\n * KUTE.remove(Tween)\n *\n * @param {KUTE.Tween} tw a new tween to add\n */\nconst remove = (tw) => {\n  const i = Tweens.indexOf(tw);\n  if (i !== -1) Tweens.splice(i, 1);\n};\n\n/**\n * KUTE.add(Tween)\n *\n * @return {KUTE.Tween[]} tw a new tween to add\n */\nconst getAll = () => Tweens;\n\n/**\n * KUTE.removeAll()\n */\nconst removeAll = () => { Tweens.length = 0; };\n\n/**\n * linkInterpolation\n * @this {KUTE.Tween}\n */\nfunction linkInterpolation() { // DON'T change\n  Object.keys(linkProperty).forEach((component) => {\n    const componentLink = linkProperty[component];\n    const componentProps = supportedProperties[component];\n\n    Object.keys(componentLink).forEach((fnObj) => {\n      if (typeof (componentLink[fnObj]) === 'function' // ATTR, colors, scroll, boxModel, borderRadius\n          && Object.keys(this.valuesEnd).some((i) => (componentProps && componentProps.includes(i))\n          || (i === 'attr' && Object.keys(this.valuesEnd[i]).some((j) => componentProps && componentProps.includes(j))))) {\n        if (!KEC[fnObj]) KEC[fnObj] = componentLink[fnObj];\n      } else {\n        Object.keys(this.valuesEnd).forEach((prop) => {\n          const propObject = this.valuesEnd[prop];\n          if (propObject instanceof Object) {\n            Object.keys(propObject).forEach((i) => {\n              if (typeof (componentLink[i]) === 'function') { // transformCSS3\n                if (!KEC[i]) KEC[i] = componentLink[i];\n              } else {\n                Object.keys(componentLink[fnObj]).forEach((j) => {\n                  if (componentLink[i] && typeof (componentLink[i][j]) === 'function') { // transformMatrix\n                    if (!KEC[j]) KEC[j] = componentLink[i][j];\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n  });\n}\n\nconst internals = {\n  add,\n  remove,\n  getAll,\n  removeAll,\n  stop,\n  linkInterpolation,\n};\n\n/**\n * getInlineStyle\n * Returns the transform style for element from\n * cssText. Used by for the `.to()` static method.\n *\n * @param {Element} el target element\n * @returns {object}\n */\nfunction getInlineStyle(el) {\n  // if the scroll applies to `window` it returns as it has no styling\n  if (!el.style) return false;\n  // the cssText | the resulting transform object\n  const css = el.style.cssText.replace(/\\s/g, '').split(';');\n  const transformObject = {};\n  const arrayFn = ['translate3d', 'translate', 'scale3d', 'skew'];\n\n  css.forEach((cs) => {\n    if (/transform/i.test(cs)) {\n      // all transform properties\n      const tps = cs.split(':')[1].split(')');\n      tps.forEach((tpi) => {\n        const tpv = tpi.split('(');\n        const tp = tpv[0];\n        // each transform property\n        const tv = tpv[1];\n        if (!/matrix/.test(tp)) {\n          transformObject[tp] = arrayFn.includes(tp) ? tv.split(',') : tv;\n        }\n      });\n    }\n  });\n\n  return transformObject;\n}\n\n/**\n * getStyleForProperty\n *\n * Returns the computed style property for element for .to() method.\n * Used by for the `.to()` static method.\n *\n * @param {Element} elem\n * @param {string} propertyName\n * @returns {string}\n */\nfunction getStyleForProperty(elem, propertyName) {\n  let result = defaultValues[propertyName];\n  const styleAttribute = elem.style;\n  const computedStyle = getComputedStyle(elem) || elem.currentStyle;\n  const styleValue = styleAttribute[propertyName] && !/auto|initial|none|unset/.test(styleAttribute[propertyName])\n    ? styleAttribute[propertyName]\n    : computedStyle[propertyName];\n\n  if (propertyName !== 'transform' && (propertyName in computedStyle || propertyName in styleAttribute)) {\n    result = styleValue;\n  }\n\n  return result;\n}\n\n/**\n * prepareObject\n *\n * Returns all processed valuesStart / valuesEnd.\n *\n * @param {Element} obj the values start/end object\n * @param {string} fn toggles between the two\n */\nfunction prepareObject(obj, fn) { // this, props object, type: start/end\n  const propertiesObject = fn === 'start' ? this.valuesStart : this.valuesEnd;\n\n  Object.keys(prepareProperty).forEach((component) => {\n    const prepareComponent = prepareProperty[component];\n    const supportComponent = supportedProperties[component];\n\n    Object.keys(prepareComponent).forEach((tweenCategory) => {\n      const transformObject = {};\n\n      Object.keys(obj).forEach((tweenProp) => {\n        // scroll, opacity, other components\n        if (defaultValues[tweenProp] && prepareComponent[tweenProp]) {\n          propertiesObject[tweenProp] = prepareComponent[tweenProp]\n            .call(this, tweenProp, obj[tweenProp]);\n\n        // transform\n        } else if (!defaultValues[tweenCategory] && tweenCategory === 'transform'\n          && supportComponent.includes(tweenProp)) {\n          transformObject[tweenProp] = obj[tweenProp];\n\n        // allow transformFunctions to work with preprocessed input values\n        } else if (!defaultValues[tweenProp] && tweenProp === 'transform') {\n          propertiesObject[tweenProp] = obj[tweenProp];\n\n        // colors, boxModel, category\n        } else if (!defaultValues[tweenCategory]\n          && supportComponent && supportComponent.includes(tweenProp)) {\n          propertiesObject[tweenProp] = prepareComponent[tweenCategory]\n            .call(this, tweenProp, obj[tweenProp]);\n        }\n      });\n\n      // we filter out older browsers by checking Object.keys\n      if (Object.keys(transformObject).length) {\n        propertiesObject[tweenCategory] = prepareComponent[tweenCategory]\n          .call(this, tweenCategory, transformObject);\n      }\n    });\n  });\n}\n\n/**\n * getStartValues\n *\n * Returns the start values for to() method.\n * Used by for the `.to()` static method.\n *\n * @this {KUTE.Tween} the tween instance\n */\nfunction getStartValues() {\n  const startValues = {};\n  const currentStyle = getInlineStyle(this.element);\n\n  Object.keys(this.valuesStart).forEach((tweenProp) => {\n    Object.keys(prepareStart).forEach((component) => {\n      const componentStart = prepareStart[component];\n\n      Object.keys(componentStart).forEach((tweenCategory) => {\n        // clip, opacity, scroll\n        if (tweenCategory === tweenProp && componentStart[tweenProp]) {\n          startValues[tweenProp] = componentStart[tweenCategory]\n            .call(this, tweenProp, this.valuesStart[tweenProp]);\n        // find in an array of properties\n        } else if (supportedProperties[component]\n          && supportedProperties[component].includes(tweenProp)) {\n          startValues[tweenProp] = componentStart[tweenCategory]\n            .call(this, tweenProp, this.valuesStart[tweenProp]);\n        }\n      });\n    });\n  });\n\n  // stack transformCSS props for .to() chains\n  // also add to startValues values from previous tweens\n  Object.keys(currentStyle).forEach((current) => {\n    if (!(current in this.valuesStart)) {\n      startValues[current] = currentStyle[current] || defaultValues[current];\n    }\n  });\n\n  this.valuesStart = {};\n  prepareObject.call(this, startValues, 'start');\n}\n\nvar Process = {\n  getInlineStyle,\n  getStyleForProperty,\n  getStartValues,\n  prepareObject,\n};\n\nconst connect = {};\n/** @type {KUTE.TweenBase | KUTE.Tween | KUTE.TweenExtra} */\nconnect.tween = null;\nconnect.processEasing = null;\n\nconst Easing = {\n  linear: new CubicBezier(0, 0, 1, 1, 'linear'),\n  easingSinusoidalIn: new CubicBezier(0.47, 0, 0.745, 0.715, 'easingSinusoidalIn'),\n  easingSinusoidalOut: new CubicBezier(0.39, 0.575, 0.565, 1, 'easingSinusoidalOut'),\n  easingSinusoidalInOut: new CubicBezier(0.445, 0.05, 0.55, 0.95, 'easingSinusoidalInOut'),\n\n  easingQuadraticIn: new CubicBezier(0.550, 0.085, 0.680, 0.530, 'easingQuadraticIn'),\n  easingQuadraticOut: new CubicBezier(0.250, 0.460, 0.450, 0.940, 'easingQuadraticOut'),\n  easingQuadraticInOut: new CubicBezier(0.455, 0.030, 0.515, 0.955, 'easingQuadraticInOut'),\n\n  easingCubicIn: new CubicBezier(0.55, 0.055, 0.675, 0.19, 'easingCubicIn'),\n  easingCubicOut: new CubicBezier(0.215, 0.61, 0.355, 1, 'easingCubicOut'),\n  easingCubicInOut: new CubicBezier(0.645, 0.045, 0.355, 1, 'easingCubicInOut'),\n\n  easingQuarticIn: new CubicBezier(0.895, 0.03, 0.685, 0.22, 'easingQuarticIn'),\n  easingQuarticOut: new CubicBezier(0.165, 0.84, 0.44, 1, 'easingQuarticOut'),\n  easingQuarticInOut: new CubicBezier(0.77, 0, 0.175, 1, 'easingQuarticInOut'),\n\n  easingQuinticIn: new CubicBezier(0.755, 0.05, 0.855, 0.06, 'easingQuinticIn'),\n  easingQuinticOut: new CubicBezier(0.23, 1, 0.32, 1, 'easingQuinticOut'),\n  easingQuinticInOut: new CubicBezier(0.86, 0, 0.07, 1, 'easingQuinticInOut'),\n\n  easingExponentialIn: new CubicBezier(0.95, 0.05, 0.795, 0.035, 'easingExponentialIn'),\n  easingExponentialOut: new CubicBezier(0.19, 1, 0.22, 1, 'easingExponentialOut'),\n  easingExponentialInOut: new CubicBezier(1, 0, 0, 1, 'easingExponentialInOut'),\n\n  easingCircularIn: new CubicBezier(0.6, 0.04, 0.98, 0.335, 'easingCircularIn'),\n  easingCircularOut: new CubicBezier(0.075, 0.82, 0.165, 1, 'easingCircularOut'),\n  easingCircularInOut: new CubicBezier(0.785, 0.135, 0.15, 0.86, 'easingCircularInOut'),\n\n  easingBackIn: new CubicBezier(0.6, -0.28, 0.735, 0.045, 'easingBackIn'),\n  easingBackOut: new CubicBezier(0.175, 0.885, 0.32, 1.275, 'easingBackOut'),\n  easingBackInOut: new CubicBezier(0.68, -0.55, 0.265, 1.55, 'easingBackInOut'),\n};\n\n/**\n * Returns a valid `easingFunction`.\n *\n * @param {KUTE.easingFunction | string} fn function name or constructor name\n * @returns {KUTE.easingFunction} a valid easingfunction\n */\nfunction processBezierEasing(fn) {\n  if (typeof fn === 'function') {\n    return fn;\n  } if (typeof (Easing[fn]) === 'function') {\n    return Easing[fn];\n  } if (/bezier/.test(fn)) {\n    const bz = fn.replace(/bezier|\\s|\\(|\\)/g, '').split(',');\n    return new CubicBezier(bz[0] * 1, bz[1] * 1, bz[2] * 1, bz[3] * 1); // bezier easing\n  }\n  // if (/elastic|bounce/i.test(fn)) {\n  //   throw TypeError(`KUTE - CubicBezier doesn't support ${fn} easing.`);\n  // }\n  return Easing.linear;\n}\n\nconnect.processEasing = processBezierEasing;\n\n/**\n * selector\n *\n * A selector utility for KUTE.js.\n *\n * @param {KUTE.selectorType} el target(s) or string selector\n * @param {boolean | number} multi when true returns an array/collection of elements\n * @returns {Element | Element[] | null}\n */\nfunction selector(el, multi) {\n  try {\n    let requestedElem;\n    let itemsArray;\n    if (multi) {\n      itemsArray = el instanceof Array && el.every((x) => x instanceof Element);\n      requestedElem = el instanceof HTMLCollection || el instanceof NodeList || itemsArray\n        ? el : document.querySelectorAll(el);\n    } else {\n      requestedElem = el instanceof Element || el === window // scroll\n        ? el : document.querySelector(el);\n    }\n    return requestedElem;\n  } catch (e) {\n    throw TypeError(`KUTE.js - Element(s) not found: ${el}.`);\n  }\n}\n\nfunction queueStart() {\n  // fire onStart actions\n  Object.keys(onStart).forEach((obj) => {\n    if (typeof (onStart[obj]) === 'function') {\n      onStart[obj].call(this, obj); // easing functions\n    } else {\n      Object.keys(onStart[obj]).forEach((prop) => {\n        onStart[obj][prop].call(this, prop);\n      });\n    }\n  });\n\n  // add interpolations\n  linkInterpolation.call(this);\n}\n\n/**\n * The `TweenBase` constructor creates a new `Tween` object\n * for a single `HTMLElement` and returns it.\n *\n * `TweenBase` is meant to be used with pre-processed values.\n */\nclass TweenBase {\n  /**\n   * @param {Element} targetElement the target element\n   * @param {KUTE.tweenProps} startObject the start values\n   * @param {KUTE.tweenProps} endObject the end values\n   * @param {KUTE.tweenOptions} opsObject the end values\n   * @returns {TweenBase} the resulting Tween object\n   */\n  constructor(targetElement, startObject, endObject, opsObject) {\n    // element animation is applied to\n    this.element = targetElement;\n\n    /** @type {boolean} */\n    this.playing = false;\n    /** @type {number?} */\n    this._startTime = null;\n    /** @type {boolean} */\n    this._startFired = false;\n\n    // type is set via KUTE.tweenProps\n    this.valuesEnd = endObject;\n    this.valuesStart = startObject;\n\n    // OPTIONS\n    const options = opsObject || {};\n    // internal option to process inline/computed style at start instead of init\n    // used by to() method and expects object : {} / false\n    this._resetStart = options.resetStart || 0;\n    // you can only set a core easing function as default\n    /** @type {KUTE.easingOption} */\n    this._easing = typeof (options.easing) === 'function' ? options.easing : connect.processEasing(options.easing);\n    /** @type {number} */\n    this._duration = options.duration || defaultOptions$1.duration; // duration option | default\n    /** @type {number} */\n    this._delay = options.delay || defaultOptions$1.delay; // delay option | default\n\n    // set other options\n    Object.keys(options).forEach((op) => {\n      const internalOption = `_${op}`;\n      if (!(internalOption in this)) this[internalOption] = options[op];\n    });\n\n    // callbacks should not be set as undefined\n    // this._onStart = options.onStart\n    // this._onUpdate = options.onUpdate\n    // this._onStop = options.onStop\n    // this._onComplete = options.onComplete\n\n    // queue the easing\n    const easingFnName = this._easing.name;\n    if (!onStart[easingFnName]) {\n      onStart[easingFnName] = function easingFn(prop) {\n        if (!KEC[prop] && prop === this._easing.name) KEC[prop] = this._easing;\n      };\n    }\n\n    return this;\n  }\n\n  /**\n   * Starts tweening\n   * @param {number?} time the tween start time\n   * @returns {TweenBase} this instance\n   */\n  start(time) {\n    // now it's a good time to start\n    add(this);\n    this.playing = true;\n\n    this._startTime = typeof time !== 'undefined' ? time : KEC.Time();\n    this._startTime += this._delay;\n\n    if (!this._startFired) {\n      if (this._onStart) {\n        this._onStart.call(this);\n      }\n\n      queueStart.call(this);\n\n      this._startFired = true;\n    }\n\n    if (!Tick) Ticker();\n    return this;\n  }\n\n  /**\n   * Stops tweening\n   * @returns {TweenBase} this instance\n   */\n  stop() {\n    if (this.playing) {\n      remove(this);\n      this.playing = false;\n\n      if (this._onStop) {\n        this._onStop.call(this);\n      }\n      this.close();\n    }\n    return this;\n  }\n\n  /**\n   * Trigger internal completion callbacks.\n   */\n  close() {\n    // scroll|transformMatrix need this\n    Object.keys(onComplete).forEach((component) => {\n      Object.keys(onComplete[component]).forEach((toClose) => {\n        onComplete[component][toClose].call(this, toClose);\n      });\n    });\n    // when all animations are finished, stop ticking after ~3 frames\n    this._startFired = false;\n    stop.call(this);\n  }\n\n  /**\n   * Schedule another tween instance to start once this one completes.\n   * @param {KUTE.chainOption} args the tween animation start time\n   * @returns {TweenBase} this instance\n   */\n  chain(args) {\n    this._chain = [];\n    this._chain = args.length ? args : this._chain.concat(args);\n    return this;\n  }\n\n  /**\n   * Stop tweening the chained tween instances.\n   */\n  stopChainedTweens() {\n    if (this._chain && this._chain.length) this._chain.forEach((tw) => tw.stop());\n  }\n\n  /**\n   * Update the tween on each tick.\n   * @param {number} time the tick time\n   * @returns {boolean} this instance\n   */\n  update(time) {\n    const T = time !== undefined ? time : KEC.Time();\n\n    let elapsed;\n\n    if (T < this._startTime && this.playing) { return true; }\n\n    elapsed = (T - this._startTime) / this._duration;\n    elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n\n    // calculate progress\n    const progress = this._easing(elapsed);\n\n    // render the update\n    Object.keys(this.valuesEnd).forEach((tweenProp) => {\n      KEC[tweenProp](this.element,\n        this.valuesStart[tweenProp],\n        this.valuesEnd[tweenProp],\n        progress);\n    });\n\n    // fire the updateCallback\n    if (this._onUpdate) {\n      this._onUpdate.call(this);\n    }\n\n    if (elapsed === 1) {\n      // fire the complete callback\n      if (this._onComplete) {\n        this._onComplete.call(this);\n      }\n\n      // now we're sure no animation is running\n      this.playing = false;\n\n      // stop ticking when finished\n      this.close();\n\n      // start animating chained tweens\n      if (this._chain !== undefined && this._chain.length) {\n        this._chain.map((tw) => tw.start());\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n}\n\n// Update Tween Interface\nconnect.tween = TweenBase;\n\n/**\n * The `KUTE.Tween()` constructor creates a new `Tween` object\n * for a single `HTMLElement` and returns it.\n *\n * This constructor adds additional functionality and is the default\n * Tween object constructor in KUTE.js.\n */\nclass Tween extends TweenBase {\n  /**\n   * @param {KUTE.tweenParams} args (*target*, *startValues*, *endValues*, *options*)\n   * @returns {Tween} the resulting Tween object\n   */\n  constructor(...args) {\n    super(...args); // this calls the constructor of TweenBase\n\n    // reset interpolation values\n    this.valuesStart = {};\n    this.valuesEnd = {};\n\n    // const startObject = args[1];\n    // const endObject = args[2];\n    const [startObject, endObject, options] = args.slice(1);\n\n    // set valuesEnd\n    prepareObject.call(this, endObject, 'end');\n\n    // set valuesStart\n    if (this._resetStart) {\n      this.valuesStart = startObject;\n    } else {\n      prepareObject.call(this, startObject, 'start');\n    }\n\n    // ready for crossCheck\n    if (!this._resetStart) {\n      Object.keys(crossCheck).forEach((component) => {\n        Object.keys(crossCheck[component]).forEach((checkProp) => {\n          crossCheck[component][checkProp].call(this, checkProp);\n        });\n      });\n    }\n\n    // set paused state\n    /** @type {boolean} */\n    this.paused = false;\n    /** @type {number?} */\n    this._pauseTime = null;\n\n    // additional properties and options\n    /** @type {number?} */\n    this._repeat = options.repeat || defaultOptions$1.repeat;\n    /** @type {number?} */\n    this._repeatDelay = options.repeatDelay || defaultOptions$1.repeatDelay;\n    // we cache the number of repeats to be able to put it back after all cycles finish\n    /** @type {number?} */\n    this._repeatOption = this._repeat;\n\n    // yoyo needs at least repeat: 1\n    /** @type {KUTE.tweenProps} */\n    this.valuesRepeat = {}; // valuesRepeat\n    /** @type {boolean} */\n    this._yoyo = options.yoyo || defaultOptions$1.yoyo;\n    /** @type {boolean} */\n    this._reversed = false;\n\n    // don't load extra callbacks\n    // this._onPause = options.onPause || defaultOptions.onPause\n    // this._onResume = options.onResume || defaultOptions.onResume\n\n    // chained Tweens\n    // this._chain = options.chain || defaultOptions.chain;\n    return this;\n  }\n\n  /**\n   * Starts tweening, extended method\n   * @param {number?} time the tween start time\n   * @returns {Tween} this instance\n   */\n  start(time) {\n    // on start we reprocess the valuesStart for TO() method\n    if (this._resetStart) {\n      this.valuesStart = this._resetStart;\n      getStartValues.call(this);\n\n      // this is where we do the valuesStart and valuesEnd check for fromTo() method\n      Object.keys(crossCheck).forEach((component) => {\n        Object.keys(crossCheck[component]).forEach((checkProp) => {\n          crossCheck[component][checkProp].call(this, checkProp);\n        });\n      });\n    }\n    // still not paused\n    this.paused = false;\n\n    // set yoyo values\n    if (this._yoyo) {\n      Object.keys(this.valuesEnd).forEach((endProp) => {\n        this.valuesRepeat[endProp] = this.valuesStart[endProp];\n      });\n    }\n\n    super.start(time);\n\n    return this;\n  }\n\n  /**\n   * Stops tweening, extended method\n   * @returns {Tween} this instance\n   */\n  stop() {\n    super.stop();\n    if (!this.paused && this.playing) {\n      this.paused = false;\n      this.stopChainedTweens();\n    }\n    return this;\n  }\n\n  /**\n   * Trigger internal completion callbacks.\n   */\n  close() {\n    super.close();\n\n    if (this._repeatOption > 0) {\n      this._repeat = this._repeatOption;\n    }\n    if (this._yoyo && this._reversed === true) {\n      this.reverse();\n      this._reversed = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Resume tweening\n   * @returns {Tween} this instance\n   */\n  resume() {\n    if (this.paused && this.playing) {\n      this.paused = false;\n      if (this._onResume !== undefined) {\n        this._onResume.call(this);\n      }\n      // re-queue execution context\n      queueStart.call(this);\n      // update time and let it roll\n      this._startTime += KEC.Time() - this._pauseTime;\n      add(this);\n      // restart ticker if stopped\n      if (!Tick) Ticker();\n    }\n    return this;\n  }\n\n  /**\n   * Pause tweening\n   * @returns {Tween} this instance\n   */\n  pause() {\n    if (!this.paused && this.playing) {\n      remove(this);\n      this.paused = true;\n      this._pauseTime = KEC.Time();\n      if (this._onPause !== undefined) {\n        this._onPause.call(this);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Reverses start values with end values\n   */\n  reverse() {\n    Object.keys(this.valuesEnd).forEach((reverseProp) => {\n      const tmp = this.valuesRepeat[reverseProp];\n      this.valuesRepeat[reverseProp] = this.valuesEnd[reverseProp];\n      this.valuesEnd[reverseProp] = tmp;\n      this.valuesStart[reverseProp] = this.valuesRepeat[reverseProp];\n    });\n  }\n\n  /**\n   * Update the tween on each tick.\n   * @param {number} time the tick time\n   * @returns {boolean} this instance\n   */\n  update(time) {\n    const T = time !== undefined ? time : KEC.Time();\n\n    let elapsed;\n\n    if (T < this._startTime && this.playing) { return true; }\n\n    elapsed = (T - this._startTime) / this._duration;\n    elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n\n    // calculate progress\n    const progress = this._easing(elapsed);\n\n    // render the update\n    Object.keys(this.valuesEnd).forEach((tweenProp) => {\n      KEC[tweenProp](this.element,\n        this.valuesStart[tweenProp],\n        this.valuesEnd[tweenProp],\n        progress);\n    });\n\n    // fire the updateCallback\n    if (this._onUpdate) {\n      this._onUpdate.call(this);\n    }\n\n    if (elapsed === 1) {\n      if (this._repeat > 0) {\n        if (Number.isFinite(this._repeat)) this._repeat -= 1;\n\n        // set the right time for delay\n        this._startTime = T;\n        if (Number.isFinite(this._repeat) && this._yoyo && !this._reversed) {\n          this._startTime += this._repeatDelay;\n        }\n\n        if (this._yoyo) { // handle yoyo\n          this._reversed = !this._reversed;\n          this.reverse();\n        }\n\n        return true;\n      }\n\n      // fire the complete callback\n      if (this._onComplete) {\n        this._onComplete.call(this);\n      }\n\n      // now we're sure no animation is running\n      this.playing = false;\n\n      // stop ticking when finished\n      this.close();\n\n      // start animating chained tweens\n      if (this._chain !== undefined && this._chain.length) {\n        this._chain.forEach((tw) => tw.start());\n      }\n\n      return false;\n    }\n    return true;\n  }\n}\n\n// Update Tween Interface Update\nconnect.tween = Tween;\n\n/**\n * The static method creates a new `Tween` object for each `HTMLElement`\n * from and `Array`, `HTMLCollection` or `NodeList`.\n */\nclass TweenCollection {\n  /**\n   *\n   * @param {Element[] | HTMLCollection | NodeList} els target elements\n   * @param {KUTE.tweenProps} vS the start values\n   * @param {KUTE.tweenProps} vE the end values\n   * @param {KUTE.tweenOptions} Options tween options\n   * @returns {TweenCollection} the Tween object collection\n   */\n  constructor(els, vS, vE, Options) {\n    const TweenConstructor = connect.tween;\n    /** @type {KUTE.twCollection[]} */\n    this.tweens = [];\n\n    const Ops = Options || {};\n    /** @type {number?} */\n    Ops.delay = Ops.delay || defaultOptions$1.delay;\n\n    // set all options\n    const options = [];\n\n    Array.from(els).forEach((el, i) => {\n      options[i] = Ops || {};\n      options[i].delay = i > 0 ? Ops.delay + (Ops.offset || defaultOptions$1.offset) : Ops.delay;\n      if (el instanceof Element) {\n        this.tweens.push(new TweenConstructor(el, vS, vE, options[i]));\n      } else {\n        throw Error(`KUTE - ${el} is not instanceof Element`);\n      }\n    });\n\n    /** @type {number?} */\n    this.length = this.tweens.length;\n    return this;\n  }\n\n  /**\n   * Starts tweening, all targets\n   * @param {number?} time the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  start(time) {\n    const T = time === undefined ? KEC.Time() : time;\n    this.tweens.map((tween) => tween.start(T));\n    return this;\n  }\n\n  /**\n   * Stops tweening, all targets and their chains\n   * @returns {TweenCollection} this instance\n   */\n  stop() {\n    this.tweens.map((tween) => tween.stop());\n    return this;\n  }\n\n  /**\n   * Pause tweening, all targets\n   * @returns {TweenCollection} this instance\n   */\n  pause() {\n    this.tweens.map((tween) => tween.pause());\n    return this;\n  }\n\n  /**\n   * Resume tweening, all targets\n   * @returns {TweenCollection} this instance\n   */\n  resume() {\n    this.tweens.map((tween) => tween.resume());\n    return this;\n  }\n\n  /**\n   * Schedule another tween or collection to start after\n   * this one is complete.\n   * @param {number?} args the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  chain(args) {\n    const lastTween = this.tweens[this.length - 1];\n    if (args instanceof TweenCollection) {\n      lastTween.chain(args.tweens);\n    } else if (args instanceof connect.tween) {\n      lastTween.chain(args);\n    } else {\n      throw new TypeError('KUTE.js - invalid chain value');\n    }\n    return this;\n  }\n\n  /**\n   * Check if any tween instance is playing\n   * @param {number?} time the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  playing() {\n    return this.tweens.some((tw) => tw.playing);\n  }\n\n  /**\n   * Remove all tweens in the collection\n   */\n  removeTweens() {\n    this.tweens = [];\n  }\n\n  /**\n   * Returns the maximum animation duration\n   * @returns {number} this instance\n   */\n  getMaxDuration() {\n    const durations = [];\n    this.tweens.forEach((tw) => {\n      durations.push(tw._duration + tw._delay + tw._repeat * tw._repeatDelay);\n    });\n    return Math.max(durations);\n  }\n}\n\nconst { tween: TweenConstructor$1 } = connect;\n\n/**\n * The `KUTE.to()` static method returns a new Tween object\n * for a single `HTMLElement` at its current state.\n *\n * @param {Element} element target element\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {KUTE.Tween} the resulting Tween object\n */\nfunction to(element, endObject, optionsObj) {\n  const options = optionsObj || {};\n  options.resetStart = endObject;\n  return new TweenConstructor$1(selector(element), endObject, endObject, options);\n}\n\nconst { tween: TweenConstructor } = connect;\n\n/**\n * The `KUTE.fromTo()` static method returns a new Tween object\n * for a single `HTMLElement` at a given state.\n *\n * @param {Element} element target element\n * @param {KUTE.tweenProps} startObject\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {KUTE.Tween} the resulting Tween object\n */\nfunction fromTo(element, startObject, endObject, optionsObj) {\n  const options = optionsObj || {};\n  return new TweenConstructor(selector(element), startObject, endObject, options);\n}\n\n/**\n * The `KUTE.allTo()` static method creates a new Tween object\n * for multiple `HTMLElement`s, `HTMLCollection` or `NodeListat`\n * at their current state.\n *\n * @param {Element[] | HTMLCollection | NodeList} elements target elements\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenProps} optionsObj progress\n * @returns {TweenCollection} the Tween object collection\n */\nfunction allTo(elements, endObject, optionsObj) {\n  const options = optionsObj || {};\n  options.resetStart = endObject;\n  return new TweenCollection(selector(elements, true), endObject, endObject, options);\n}\n\n/**\n * The `KUTE.allFromTo()` static method creates a new Tween object\n * for multiple `HTMLElement`s, `HTMLCollection` or `NodeListat`\n * at a given state.\n *\n * @param {Element[] | HTMLCollection | NodeList} elements target elements\n * @param {KUTE.tweenProps} startObject\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {TweenCollection} the Tween object collection\n */\nfunction allFromTo(elements, startObject, endObject, optionsObj) {\n  const options = optionsObj || {};\n  return new TweenCollection(selector(elements, true), startObject, endObject, options);\n}\n\n/**\n * Animation Class\n *\n * Registers components by populating KUTE.js objects and makes sure\n * no duplicate component / property is allowed.\n */\nclass Animation {\n  /**\n   * @constructor\n   * @param {KUTE.fullComponent} Component\n   */\n  constructor(Component) {\n    try {\n      if (Component.component in supportedProperties) {\n        throw Error(`KUTE - ${Component.component} already registered`);\n      } else if (Component.property in defaultValues) {\n        throw Error(`KUTE - ${Component.property} already registered`);\n      }\n    } catch (e) {\n      throw Error(e);\n    }\n\n    const propertyInfo = this;\n    const ComponentName = Component.component;\n    // const Objects = { defaultValues, defaultOptions, Interpolate, linkProperty, Util }\n    const Functions = {\n      prepareProperty, prepareStart, onStart, onComplete, crossCheck,\n    };\n    const Category = Component.category;\n    const Property = Component.property;\n    const Length = (Component.properties && Component.properties.length)\n      || (Component.subProperties && Component.subProperties.length);\n\n    // single property\n    // {property,defaultvalue,defaultOptions,Interpolate,functions}\n\n    // category colors, boxModel, borderRadius\n    // {category,properties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // property with multiple sub properties. Eg transform, filter\n    // {property,subProperties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // property with multiple sub properties. Eg htmlAttributes\n    // {category,subProperties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // set supported category/property\n    supportedProperties[ComponentName] = Component.properties\n      || Component.subProperties || Component.property;\n\n    // set defaultValues\n    if ('defaultValue' in Component) { // value 0 will invalidate\n      defaultValues[Property] = Component.defaultValue;\n\n      // minimal info\n      propertyInfo.supports = `${Property} property`;\n    } else if (Component.defaultValues) {\n      Object.keys(Component.defaultValues).forEach((dv) => {\n        defaultValues[dv] = Component.defaultValues[dv];\n      });\n\n      // minimal info\n      propertyInfo.supports = `${Length || Property} ${Property || Category} properties`;\n    }\n\n    // set additional options\n    if (Component.defaultOptions) {\n      // Object.keys(Component.defaultOptions).forEach((op) => {\n      //   defaultOptions[op] = Component.defaultOptions[op];\n      // });\n      Object.assign(defaultOptions$1, Component.defaultOptions);\n    }\n\n    // set functions\n    if (Component.functions) {\n      Object.keys(Functions).forEach((fn) => {\n        if (fn in Component.functions) {\n          if (typeof (Component.functions[fn]) === 'function') {\n            // if (!Functions[fn][ Category||Property ]) {\n            //   Functions[fn][ Category||Property ] = Component.functions[fn];\n            // }\n            if (!Functions[fn][ComponentName]) Functions[fn][ComponentName] = {};\n            if (!Functions[fn][ComponentName][Category || Property]) {\n              Functions[fn][ComponentName][Category || Property] = Component.functions[fn];\n            }\n          } else {\n            Object.keys(Component.functions[fn]).forEach((ofn) => {\n              // !Functions[fn][ofn] && (Functions[fn][ofn] = Component.functions[fn][ofn])\n              if (!Functions[fn][ComponentName]) Functions[fn][ComponentName] = {};\n              if (!Functions[fn][ComponentName][ofn]) {\n                Functions[fn][ComponentName][ofn] = Component.functions[fn][ofn];\n              }\n            });\n          }\n        }\n      });\n    }\n\n    // set component interpolation functions\n    if (Component.Interpolate) {\n      Object.keys(Component.Interpolate).forEach((fni) => {\n        const compIntObj = Component.Interpolate[fni];\n        if (typeof (compIntObj) === 'function' && !interpolate[fni]) {\n          interpolate[fni] = compIntObj;\n        } else {\n          Object.keys(compIntObj).forEach((sfn) => {\n            if (typeof (compIntObj[sfn]) === 'function' && !interpolate[fni]) {\n              interpolate[fni] = compIntObj[sfn];\n            }\n          });\n        }\n      });\n\n      linkProperty[ComponentName] = Component.Interpolate;\n    }\n\n    // set component util\n    if (Component.Util) {\n      Object.keys(Component.Util).forEach((fnu) => {\n        if (!Util[fnu]) Util[fnu] = Component.Util[fnu];\n      });\n    }\n\n    return propertyInfo;\n  }\n}\n\n/**\n * trueDimension\n *\n * Returns the string value of a specific CSS property converted into a nice\n * { v = value, u = unit } object.\n *\n * @param {string} dimValue the property string value\n * @param {boolean | number} isAngle sets the utility to investigate angles\n * @returns {{v: number, u: string}} the true {value, unit} tuple\n */\nconst trueDimension = (dimValue, isAngle) => {\n  const intValue = parseInt(dimValue, 10) || 0;\n  const mUnits = ['px', '%', 'deg', 'rad', 'em', 'rem', 'vh', 'vw'];\n  let theUnit;\n\n  for (let mIndex = 0; mIndex < mUnits.length; mIndex += 1) {\n    if (typeof dimValue === 'string' && dimValue.includes(mUnits[mIndex])) {\n      theUnit = mUnits[mIndex]; break;\n    }\n  }\n  if (theUnit === undefined) {\n    theUnit = isAngle ? 'deg' : 'px';\n  }\n\n  return { v: intValue, u: theUnit };\n};\n\n/**\n * Numbers Interpolation Function.\n *\n * @param {number} a start value\n * @param {number} b end value\n * @param {number} v progress\n * @returns {number} the interpolated number\n */\nfunction numbers(a, b, v) {\n  const A = +a;\n  const B = b - a;\n  // a = +a; b -= a;\n  return A + B * v;\n}\n\n// Component Functions\n/**\n * Sets the update function for the property.\n * @param {string} tweenProp the property name\n */\nfunction boxModelOnStart(tweenProp) {\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable no-param-reassign -- impossible to satisfy */\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n      elem.style[tweenProp] = `${v > 0.99 || v < 0.01\n        ? ((numbers(a, b, v) * 10) >> 0) / 10\n        : (numbers(a, b, v)) >> 0}px`;\n      /* eslint-enable no-bitwise */\n      /* eslint-enable no-param-reassign */\n    };\n  }\n}\n\n// Component Functions\n/**\n * Returns the current property computed style.\n * @param {string} tweenProp the property name\n * @returns {string} computed style for property\n */\nfunction getBoxModel(tweenProp) {\n  return getStyleForProperty(this.element, tweenProp) || defaultValues[tweenProp];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} value the property name\n * @returns {number} the property tween object\n */\nfunction prepareBoxModel(tweenProp, value) {\n  const boxValue = trueDimension(value);\n  const offsetProp = tweenProp === 'height' ? 'offsetHeight' : 'offsetWidth';\n  return boxValue.u === '%' ? (boxValue.v * this.element[offsetProp]) / 100 : boxValue.v;\n}\n\n// Component Base Props\nconst essentialBoxProps = ['top', 'left', 'width', 'height'];\nconst essentialBoxPropsValues = {\n  top: 0, left: 0, width: 0, height: 0,\n};\n\nconst essentialBoxOnStart = {};\nessentialBoxProps.forEach((x) => { essentialBoxOnStart[x] = boxModelOnStart; });\n\n// All Component Functions\nconst essentialBoxModelFunctions = {\n  prepareStart: getBoxModel,\n  prepareProperty: prepareBoxModel,\n  onStart: essentialBoxOnStart,\n};\n\n// Component Essential\nconst BoxModelEssential = {\n  component: 'essentialBoxModel',\n  category: 'boxModel',\n  properties: essentialBoxProps,\n  defaultValues: essentialBoxPropsValues,\n  Interpolate: { numbers },\n  functions: essentialBoxModelFunctions,\n  Util: { trueDimension },\n};\n\n/**\n * hexToRGB\n *\n * Converts a #HEX color format into RGB\n * and returns a color object {r,g,b}.\n *\n * @param {string} hex the degree angle\n * @returns {KUTE.colorObject | null} the radian angle\n */\nconst hexToRGB = (hex) => {\n  // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n  const hexShorthand = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  const HEX = hex.replace(hexShorthand, (_, r, g, b) => r + r + g + g + b + b);\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(HEX);\n\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16),\n  } : null;\n};\n\n/**\n * trueColor\n *\n * Transform any color to rgba()/rgb() and return a nice RGB(a) object.\n *\n * @param {string} colorString the color input\n * @returns {KUTE.colorObject} the {r,g,b,a} color object\n */\nconst trueColor = (colorString) => {\n  let result;\n  if (/rgb|rgba/.test(colorString)) { // first check if it's a rgb string\n    const vrgb = colorString.replace(/\\s|\\)/, '').split('(')[1].split(',');\n    const colorAlpha = vrgb[3] ? vrgb[3] : null;\n    if (!colorAlpha) {\n      result = { r: parseInt(vrgb[0], 10), g: parseInt(vrgb[1], 10), b: parseInt(vrgb[2], 10) };\n    } else {\n      result = {\n        r: parseInt(vrgb[0], 10),\n        g: parseInt(vrgb[1], 10),\n        b: parseInt(vrgb[2], 10),\n        a: parseFloat(colorAlpha),\n      };\n    }\n  } if (/^#/.test(colorString)) {\n    const fromHex = hexToRGB(colorString);\n    result = { r: fromHex.r, g: fromHex.g, b: fromHex.b };\n  } if (/transparent|none|initial|inherit/.test(colorString)) {\n    result = {\n      r: 0, g: 0, b: 0, a: 0,\n    };\n  }\n  // maybe we can check for web safe colors\n  // only works in a browser\n  if (!/^#|^rgb/.test(colorString)) {\n    const siteHead = document.getElementsByTagName('head')[0];\n    siteHead.style.color = colorString;\n    let webColor = getComputedStyle(siteHead, null).color;\n    webColor = /rgb/.test(webColor) ? webColor.replace(/[^\\d,]/g, '').split(',') : [0, 0, 0];\n    siteHead.style.color = '';\n    result = {\n      r: parseInt(webColor[0], 10),\n      g: parseInt(webColor[1], 10),\n      b: parseInt(webColor[2], 10),\n    };\n  }\n  return result;\n};\n\n/**\n * Color Interpolation Function.\n *\n * @param {KUTE.colorObject} a start color\n * @param {KUTE.colorObject} b end color\n * @param {number} v progress\n * @returns {string} the resulting color\n */\nfunction colors(a, b, v) {\n  const _c = {};\n  const ep = ')';\n  const cm = ',';\n  const rgb = 'rgb(';\n  const rgba = 'rgba(';\n\n  Object.keys(b).forEach((c) => {\n    if (c !== 'a') {\n      _c[c] = numbers(a[c], b[c], v) >> 0 || 0; // eslint-disable-line no-bitwise\n    } else if (a[c] && b[c]) {\n      _c[c] = (numbers(a[c], b[c], v) * 100 >> 0) / 100; // eslint-disable-line no-bitwise\n    }\n  });\n\n  return !_c.a\n    ? rgb + _c.r + cm + _c.g + cm + _c.b + ep\n    : rgba + _c.r + cm + _c.g + cm + _c.b + cm + _c.a + ep;\n}\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartColors(tweenProp) {\n  if (this.valuesEnd[tweenProp] && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      // eslint-disable-next-line no-param-reassign\n      elem.style[tweenProp] = colors(a, b, v);\n    };\n  }\n}\n\n// Component Properties\n// supported formats\n// 'hex', 'rgb', 'rgba' '#fff' 'rgb(0,0,0)' / 'rgba(0,0,0,0)' 'red' (IE9+)\nconst supportedColors = [\n  'color', 'backgroundColor', 'outlineColor',\n  'borderColor', 'borderTopColor', 'borderRightColor',\n  'borderBottomColor', 'borderLeftColor',\n];\n\nconst defaultColors = {};\nsupportedColors.forEach((tweenProp) => {\n  defaultColors[tweenProp] = '#000';\n});\n\n// Component Functions\nconst colorsOnStart = {};\nsupportedColors.forEach((x) => {\n  colorsOnStart[x] = onStartColors;\n});\n\n/**\n * Returns the current property computed style.\n * @param {string} prop the property name\n * @returns {string} property computed style\n */\nfunction getColor(prop/* , value */) {\n  return getStyleForProperty(this.element, prop) || defaultValues[prop];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {KUTE.colorObject} the property tween object\n */\nfunction prepareColor(/* prop, */_, value) {\n  return trueColor(value);\n}\n\n// All Component Functions\nconst colorFunctions = {\n  prepareStart: getColor,\n  prepareProperty: prepareColor,\n  onStart: colorsOnStart,\n};\n\n// Component Full\nconst colorProperties = {\n  component: 'colorProperties',\n  category: 'colors',\n  properties: supportedColors,\n  defaultValues: defaultColors,\n  Interpolate: { numbers, colors },\n  functions: colorFunctions,\n  Util: { trueColor },\n};\n\n// Component Special\nconst attributes = {};\n\nconst onStartAttr = {\n  /**\n   * onStartAttr.attr\n   *\n   * Sets the sub-property update function.\n   * @param {string} tweenProp the property name\n   */\n  attr(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n      KEC[tweenProp] = (elem, vS, vE, v) => {\n        Object.keys(vE).forEach((oneAttr) => {\n          KEC.attributes[oneAttr](elem, oneAttr, vS[oneAttr], vE[oneAttr], v);\n        });\n      };\n    }\n  },\n  /**\n   * onStartAttr.attributes\n   *\n   * Sets the update function for the property.\n   * @param {string} tweenProp the property name\n   */\n  attributes(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd.attr) {\n      KEC[tweenProp] = attributes;\n    }\n  },\n};\n\n// Component Name\nconst ComponentName = 'htmlAttributes';\n\n// Component Properties\nconst svgColors = ['fill', 'stroke', 'stop-color'];\n\n// Component Util\n/**\n * Returns non-camelcase property name.\n * @param {string} a the camelcase property name\n * @returns {string} the non-camelcase property name\n */\nfunction replaceUppercase(a) { return a.replace(/[A-Z]/g, '-$&').toLowerCase(); }\n\n// Component Functions\n/**\n * Returns the current attribute value.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {{[x:string]: string}} attribute value\n */\nfunction getAttr(/* tweenProp, */_, value) {\n  const attrStartValues = {};\n  Object.keys(value).forEach((attr) => {\n    // get the value for 'fill-opacity' not fillOpacity\n    // also 'width' not the internal 'width_px'\n    const attribute = replaceUppercase(attr).replace(/_+[a-z]+/, '');\n    const currentValue = this.element.getAttribute(attribute);\n    attrStartValues[attribute] = svgColors.includes(attribute)\n      ? (currentValue || 'rgba(0,0,0,0)')\n      : (currentValue || (/opacity/i.test(attr) ? 1 : 0));\n  });\n\n  return attrStartValues;\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} attrObj the property value\n * @returns {number} the property tween object\n */\nfunction prepareAttr(tweenProp, attrObj) { // attr (string),attrObj (object)\n  const attributesObject = {};\n\n  Object.keys(attrObj).forEach((p) => {\n    const prop = replaceUppercase(p);\n    const regex = /(%|[a-z]+)$/;\n    const currentValue = this.element.getAttribute(prop.replace(/_+[a-z]+/, ''));\n\n    if (!svgColors.includes(prop)) {\n      // attributes set with unit suffixes\n      if (currentValue !== null && regex.test(currentValue)) {\n        const unit = trueDimension(currentValue).u || trueDimension(attrObj[p]).u;\n        const suffix = /%/.test(unit) ? '_percent' : `_${unit}`;\n\n        // most \"unknown\" attributes cannot register into onStart, so we manually add them\n        onStart[ComponentName][prop + suffix] = (tp) => {\n          if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n            attributes[tp] = (elem, oneAttr, a, b, v) => {\n              const _p = oneAttr.replace(suffix, '');\n              /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n              elem.setAttribute(_p, ((numbers(a.v, b.v, v) * 1000 >> 0) / 1000) + b.u);\n            };\n          }\n        };\n        attributesObject[prop + suffix] = trueDimension(attrObj[p]);\n      } else if (!regex.test(attrObj[p]) || currentValue === null\n        || (currentValue && !regex.test(currentValue))) {\n        // most \"unknown\" attributes cannot register into onStart, so we manually add them\n        onStart[ComponentName][prop] = (tp) => {\n          if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n            attributes[tp] = (elem, oneAttr, a, b, v) => {\n              elem.setAttribute(oneAttr, (numbers(a, b, v) * 1000 >> 0) / 1000);\n            };\n          }\n        };\n        attributesObject[prop] = parseFloat(attrObj[p]);\n      }\n    } else { // colors\n      // most \"unknown\" attributes cannot register into onStart, so we manually add them\n      onStart[ComponentName][prop] = (tp) => {\n        if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n          attributes[tp] = (elem, oneAttr, a, b, v) => {\n            elem.setAttribute(oneAttr, colors(a, b, v));\n          };\n        }\n      };\n      attributesObject[prop] = trueColor(attrObj[p]) || defaultValues.htmlAttributes[p];\n    }\n  });\n\n  return attributesObject;\n}\n\n// All Component Functions\nconst attrFunctions = {\n  prepareStart: getAttr,\n  prepareProperty: prepareAttr,\n  onStart: onStartAttr,\n};\n\n// Component Full\nconst htmlAttributes = {\n  component: ComponentName,\n  property: 'attr',\n  // the Animation class will need some values to validate this Object attribute\n  subProperties: ['fill', 'stroke', 'stop-color', 'fill-opacity', 'stroke-opacity'],\n  defaultValue: {\n    fill: 'rgb(0,0,0)',\n    stroke: 'rgb(0,0,0)',\n    'stop-color': 'rgb(0,0,0)',\n    opacity: 1,\n    'stroke-opacity': 1,\n    'fill-opacity': 1, // same here\n  },\n  Interpolate: { numbers, colors },\n  functions: attrFunctions,\n  // export to global for faster execution\n  Util: { replaceUppercase, trueColor, trueDimension },\n};\n\n/* opacityProperty = {\n  property: 'opacity',\n  defaultValue: 1,\n  interpolators: {numbers},\n  functions = { prepareStart, prepareProperty, onStart }\n} */\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartOpacity(tweenProp/* , value */) {\n  // opacity could be 0 sometimes, we need to check regardless\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable */\r\n      elem.style[tweenProp] = ((numbers(a, b, v) * 1000) >> 0) / 1000;\r\n      /* eslint-enable */\n    };\n  }\n}\n\n// Component Functions\n/**\n * Returns the current property computed style.\n * @param {string} tweenProp the property name\n * @returns {string} computed style for property\n */\nfunction getOpacity(tweenProp/* , value */) {\n  return getStyleForProperty(this.element, tweenProp);\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {number} the property tween object\n */\nfunction prepareOpacity(/* tweenProp, */_, value) {\n  return parseFloat(value); // opacity always FLOAT\n}\n\n// All Component Functions\nconst opacityFunctions = {\n  prepareStart: getOpacity,\n  prepareProperty: prepareOpacity,\n  onStart: onStartOpacity,\n};\n\n// Full Component\nconst OpacityProperty = {\n  component: 'opacityProperty',\n  property: 'opacity',\n  defaultValue: 1,\n  Interpolate: { numbers },\n  functions: opacityFunctions,\n};\n\n// Component Values\nconst lowerCaseAlpha = String('abcdefghijklmnopqrstuvwxyz').split(''); // lowercase\nconst upperCaseAlpha = String('abcdefghijklmnopqrstuvwxyz').toUpperCase().split(''); // uppercase\nconst nonAlpha = String(\"~!@#$%^&*()_+{}[];'<>,./?=-\").split(''); // symbols\nconst numeric = String('0123456789').split(''); // numeric\nconst alphaNumeric = lowerCaseAlpha.concat(upperCaseAlpha, numeric); // alpha numeric\nconst allTypes = alphaNumeric.concat(nonAlpha); // all caracters\n\nconst charSet = {\n  alpha: lowerCaseAlpha, // lowercase\n  upper: upperCaseAlpha, // uppercase\n  symbols: nonAlpha, // symbols\n  numeric,\n  alphanumeric: alphaNumeric,\n  all: allTypes,\n};\n\n// Component Functions\nconst onStartWrite = {\n  /**\n   * onStartWrite.text\n   *\n   * Sets the property update function.\n   * @param {string} tweenProp the property name\n   */\n  text(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n      const chars = this._textChars;\n      let charsets = charSet[defaultOptions$1.textChars];\n\n      if (chars in charSet) {\n        charsets = charSet[chars];\n      } else if (chars && chars.length) {\n        charsets = chars;\n      }\n\n      KEC[tweenProp] = (elem, a, b, v) => {\n        let initialText = '';\n        let endText = '';\n        const finalText = b === '' ? ' ' : b;\n        const firstLetterA = a.substring(0);\n        const firstLetterB = b.substring(0);\n        /* eslint-disable */\r\n        const pointer = charsets[(Math.random() * charsets.length) >> 0];\r\n\r\n        if (a === ' ') {\r\n          endText = firstLetterB\r\n            .substring(Math.min(v * firstLetterB.length, firstLetterB.length) >> 0, 0);\r\n          elem.innerHTML = v < 1 ? ((endText + pointer)) : finalText;\r\n        } else if (b === ' ') {\r\n          initialText = firstLetterA\r\n            .substring(0, Math.min((1 - v) * firstLetterA.length, firstLetterA.length) >> 0);\r\n          elem.innerHTML = v < 1 ? ((initialText + pointer)) : finalText;\r\n        } else {\r\n          initialText = firstLetterA\r\n            .substring(firstLetterA.length,\r\n              Math.min(v * firstLetterA.length, firstLetterA.length) >> 0);\r\n          endText = firstLetterB\r\n            .substring(0, Math.min(v * firstLetterB.length, firstLetterB.length) >> 0);\r\n          elem.innerHTML = v < 1 ? ((endText + pointer + initialText)) : finalText;\r\n        }\r\n        /* eslint-enable */\n      };\n    }\n  },\n  /**\n   * onStartWrite.number\n   *\n   * Sets the property update function.\n   * @param {string} tweenProp the property name\n   */\n  number(tweenProp) {\n    if (tweenProp in this.valuesEnd && !KEC[tweenProp]) { // numbers can be 0\n      KEC[tweenProp] = (elem, a, b, v) => {\n        /* eslint-disable */\r\n        elem.innerHTML = numbers(a, b, v) >> 0;\r\n        /* eslint-enable */\n      };\n    }\n  },\n};\n\n// Component Util\n// utility for multi-child targets\n// wrapContentsSpan returns an [Element] with the SPAN.tagName and a desired class\nfunction wrapContentsSpan(el, classNAME) {\n  let textWriteWrapper;\n  let newElem;\n  if (typeof (el) === 'string') {\n    newElem = document.createElement('SPAN');\n    newElem.innerHTML = el;\n    newElem.className = classNAME;\n    return newElem;\n  }\n  if (!el.children.length || (el.children.length && el.children[0].className !== classNAME)) {\n    const elementInnerHTML = el.innerHTML;\n    textWriteWrapper = document.createElement('SPAN');\n    textWriteWrapper.className = classNAME;\n    textWriteWrapper.innerHTML = elementInnerHTML;\n    /* eslint-disable no-param-reassign -- impossible to satisfy */\n    el.appendChild(textWriteWrapper);\n    el.innerHTML = textWriteWrapper.outerHTML;\n    /* eslint-enable no-param-reassign -- impossible to satisfy */\n  } else if (el.children.length && el.children[0].className === classNAME) {\n    [textWriteWrapper] = el.children;\n  }\n  return textWriteWrapper;\n}\n\nfunction getTextPartsArray(el, classNAME) {\n  let elementsArray = [];\n  const len = el.children.length;\n  if (len) {\n    const textParts = [];\n    let remainingMarkup = el.innerHTML;\n    let wrapperParts;\n\n    for (let i = 0, currentChild, childOuter, unTaggedContent; i < len; i += 1) {\n      currentChild = el.children[i];\n      childOuter = currentChild.outerHTML;\n      wrapperParts = remainingMarkup.split(childOuter);\n\n      if (wrapperParts[0] !== '') {\n        unTaggedContent = wrapContentsSpan(wrapperParts[0], classNAME);\n        textParts.push(unTaggedContent);\n        remainingMarkup = remainingMarkup.replace(wrapperParts[0], '');\n      } else if (wrapperParts[1] !== '') {\n        unTaggedContent = wrapContentsSpan(wrapperParts[1].split('<')[0], classNAME);\n        textParts.push(unTaggedContent);\n        remainingMarkup = remainingMarkup.replace(wrapperParts[0].split('<')[0], '');\n      }\n\n      if (!currentChild.classList.contains(classNAME)) currentChild.classList.add(classNAME);\n      textParts.push(currentChild);\n      remainingMarkup = remainingMarkup.replace(childOuter, '');\n    }\n\n    if (remainingMarkup !== '') {\n      const unTaggedRemaining = wrapContentsSpan(remainingMarkup, classNAME);\n      textParts.push(unTaggedRemaining);\n    }\n\n    elementsArray = elementsArray.concat(textParts);\n  } else {\n    elementsArray = elementsArray.concat([wrapContentsSpan(el, classNAME)]);\n  }\n  return elementsArray;\n}\n\nfunction setSegments(target, newText) {\n  const oldTargetSegs = getTextPartsArray(target, 'text-part');\n  const newTargetSegs = getTextPartsArray(wrapContentsSpan(newText), 'text-part');\n\n  /* eslint-disable no-param-reassign */\n  target.innerHTML = '';\n  target.innerHTML += oldTargetSegs.map((s) => { s.className += ' oldText'; return s.outerHTML; }).join('');\n  target.innerHTML += newTargetSegs.map((s) => { s.className += ' newText'; return s.outerHTML.replace(s.innerHTML, ''); }).join('');\n  /* eslint-enable no-param-reassign */\n\n  return [oldTargetSegs, newTargetSegs];\n}\n\nfunction createTextTweens(target, newText, ops) {\n  if (target.playing) return false;\n\n  const options = ops || {};\n  options.duration = 1000;\n\n  if (ops.duration === 'auto') {\n    options.duration = 'auto';\n  } else if (Number.isFinite(ops.duration * 1)) {\n    options.duration = ops.duration * 1;\n  }\n\n  const TweenContructor = connect.tween;\n  const segs = setSegments(target, newText);\n  const oldTargetSegs = segs[0];\n  const newTargetSegs = segs[1];\n  const oldTargets = [].slice.call(target.getElementsByClassName('oldText')).reverse();\n  const newTargets = [].slice.call(target.getElementsByClassName('newText'));\n\n  let textTween = [];\n  let totalDelay = 0;\n\n  textTween = textTween.concat(oldTargets.map((el, i) => {\n    options.duration = options.duration === 'auto'\n      ? oldTargetSegs[i].innerHTML.length * 75\n      : options.duration;\n    options.delay = totalDelay;\n    options.onComplete = null;\n\n    totalDelay += options.duration;\n    return new TweenContructor(el, { text: el.innerHTML }, { text: '' }, options);\n  }));\n  textTween = textTween.concat(newTargets.map((el, i) => {\n    function onComplete() {\n      /* eslint-disable no-param-reassign */\n      target.innerHTML = newText;\n      target.playing = false;\n      /* eslint-enable no-param-reassign */\n    }\n\n    options.duration = options.duration === 'auto' ? newTargetSegs[i].innerHTML.length * 75 : options.duration;\n    options.delay = totalDelay;\n    options.onComplete = i === newTargetSegs.length - 1 ? onComplete : null;\n    totalDelay += options.duration;\n\n    return new TweenContructor(el, { text: '' }, { text: newTargetSegs[i].innerHTML }, options);\n  }));\n\n  textTween.start = function startTweens() {\n    if (!target.playing) {\n      textTween.forEach((tw) => tw.start());\n      // eslint-disable-next-line no-param-reassign\n      target.playing = true;\n    }\n  };\n\n  return textTween;\n}\n\n// Component Functions\n/**\n * Returns the current element `innerHTML`.\n * @returns {string} computed style for property\n */\nfunction getWrite(/* tweenProp, value */) {\n  return this.element.innerHTML;\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} value the property value\n * @returns {number | string} the property tween object\n */\nfunction prepareText(tweenProp, value) {\n  if (tweenProp === 'number') {\n    return parseFloat(value);\n  }\n  // empty strings crash the update function\n  return value === '' ? ' ' : value;\n}\n\n// All Component Functions\nconst textWriteFunctions = {\n  prepareStart: getWrite,\n  prepareProperty: prepareText,\n  onStart: onStartWrite,\n};\n\n// Full Component\nconst TextWrite = {\n  component: 'textWriteProperties',\n  category: 'textWrite',\n  properties: ['text', 'number'],\n  defaultValues: { text: ' ', number: '0' },\n  defaultOptions: { textChars: 'alpha' },\n  Interpolate: { numbers },\n  functions: textWriteFunctions,\n  // export to global for faster execution\n  Util: { charSet, createTextTweens },\n};\n\n/**\n * Perspective Interpolation Function.\n *\n * @param {number} a start value\n * @param {number} b end value\n * @param {string} u unit\n * @param {number} v progress\n * @returns {string} the perspective function in string format\n */\nfunction perspective(a, b, u, v) {\n  // eslint-disable-next-line no-bitwise\n  return `perspective(${((a + (b - a) * v) * 1000 >> 0) / 1000}${u})`;\n}\n\n/**\n * Translate 3D Interpolation Function.\n *\n * @param {number[]} a start [x,y,z] position\n * @param {number[]} b end [x,y,z] position\n * @param {string} u unit, usually `px` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 3D translation string\n */\nfunction translate3d(a, b, u, v) {\n  const translateArray = [];\n  for (let ax = 0; ax < 3; ax += 1) {\n    translateArray[ax] = (a[ax] || b[ax]\n      // eslint-disable-next-line no-bitwise\n      ? ((a[ax] + (b[ax] - a[ax]) * v) * 1000 >> 0) / 1000 : 0) + u;\n  }\n  return `translate3d(${translateArray.join(',')})`;\n}\n\n/**\n * 3D Rotation Interpolation Function.\n *\n * @param {number} a start [x,y,z] angles\n * @param {number} b end [x,y,z] angles\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 3D rotation string\n */\nfunction rotate3d(a, b, u, v) {\n  let rotateStr = '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[0] || b[0] ? `rotateX(${((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[1] || b[1] ? `rotateY(${((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[2] || b[2] ? `rotateZ(${((a[2] + (b[2] - a[2]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  return rotateStr;\n}\n\n/**\n * Translate 2D Interpolation Function.\n *\n * @param {number[]} a start [x,y] position\n * @param {number[]} b end [x,y] position\n * @param {string} u unit, usually `px` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 2D translation string\n */\nfunction translate(a, b, u, v) {\n  const translateArray = [];\n  // eslint-disable-next-line no-bitwise\n  translateArray[0] = (a[0] === b[0] ? b[0] : ((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000) + u;\n  // eslint-disable-next-line no-bitwise\n  translateArray[1] = a[1] || b[1] ? ((a[1] === b[1] ? b[1] : ((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000) + u) : '0';\n  return `translate(${translateArray.join(',')})`;\n}\n\n/**\n * 2D Rotation Interpolation Function.\n *\n * @param {number} a start angle\n * @param {number} b end angle\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated rotation\n */\nfunction rotate(a, b, u, v) {\n  // eslint-disable-next-line no-bitwise\n  return `rotate(${((a + (b - a) * v) * 1000 >> 0) / 1000}${u})`;\n}\n\n/**\n * Scale Interpolation Function.\n *\n * @param {number} a start scale\n * @param {number} b end scale\n * @param {number} v progress\n * @returns {string} the interpolated scale\n */\nfunction scale(a, b, v) {\n  // eslint-disable-next-line no-bitwise\n  return `scale(${((a + (b - a) * v) * 1000 >> 0) / 1000})`;\n}\n\n/**\n * Skew Interpolation Function.\n *\n * @param {number} a start {x,y} angles\n * @param {number} b end {x,y} angles\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated string value of skew(s)\n */\nfunction skew(a, b, u, v) {\n  const skewArray = [];\n  // eslint-disable-next-line no-bitwise\n  skewArray[0] = (a[0] === b[0] ? b[0] : ((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000) + u;\n  // eslint-disable-next-line no-bitwise\n  skewArray[1] = a[1] || b[1] ? ((a[1] === b[1] ? b[1] : ((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000) + u) : '0';\n  return `skew(${skewArray.join(',')})`;\n}\n\n// Component Functions\n/**\n * Sets the property update function.\n * * same to svgTransform, htmlAttributes\n * @param {string} tweenProp the property name\n */\nfunction onStartTransform(tweenProp) {\n  if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      // eslint-disable-next-line no-param-reassign\n      elem.style[tweenProp] = (a.perspective || b.perspective ? perspective(a.perspective, b.perspective, 'px', v) : '') // one side might be 0\n        + (a.translate3d ? translate3d(a.translate3d, b.translate3d, 'px', v) : '') // array [x,y,z]\n        + (a.rotate3d ? rotate3d(a.rotate3d, b.rotate3d, 'deg', v) : '') // array [x,y,z]\n        + (a.skew ? skew(a.skew, b.skew, 'deg', v) : '') // array [x,y]\n        + (a.scale || b.scale ? scale(a.scale, b.scale, v) : ''); // one side might be 0\n    };\n  }\n}\n\n// same to svg transform, attr\n// the component developed for modern browsers supporting non-prefixed transform\n\n// Component Functions\n/**\n * Returns the current property inline style.\n * @param {string} tweenProp the property name\n * @returns {string} inline style for property\n */\nfunction getTransform(tweenProp/* , value */) {\n  const currentStyle = getInlineStyle(this.element);\n  return currentStyle[tweenProp] ? currentStyle[tweenProp] : defaultValues[tweenProp];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {Object<string, string | number | (string | number)[]>} obj the property value\n * @returns {KUTE.transformFObject} the property tween object\n */\nfunction prepareTransform(/* prop, */_, obj) {\n  const prepAxis = ['X', 'Y', 'Z']; // coordinates\n  const transformObject = {};\n  const translateArray = []; const rotateArray = []; const skewArray = [];\n  const arrayFunctions = ['translate3d', 'translate', 'rotate3d', 'skew'];\n\n  Object.keys(obj).forEach((x) => {\n    const pv = typeof obj[x] === 'object' && obj[x].length\n      ? obj[x].map((v) => parseInt(v, 10))\n      : parseInt(obj[x], 10);\n\n    if (arrayFunctions.includes(x)) {\n      const propId = x === 'translate' || x === 'rotate' ? `${x}3d` : x;\n\n      if (x === 'skew') {\n        transformObject[propId] = pv.length\n          ? [pv[0] || 0, pv[1] || 0]\n          : [pv || 0, 0];\n      } else if (x === 'translate') {\n        transformObject[propId] = pv.length\n          ? [pv[0] || 0, pv[1] || 0, pv[2] || 0]\n          : [pv || 0, 0, 0];\n      } else { // translate3d | rotate3d\n        transformObject[propId] = [pv[0] || 0, pv[1] || 0, pv[2] || 0];\n      }\n    } else if (/[XYZ]/.test(x)) {\n      const fn = x.replace(/[XYZ]/, '');\n      const fnId = fn === 'skew' ? fn : `${fn}3d`;\n      const fnLen = fn === 'skew' ? 2 : 3;\n      let fnArray = [];\n\n      if (fn === 'translate') {\n        fnArray = translateArray;\n      } else if (fn === 'rotate') {\n        fnArray = rotateArray;\n      } else if (fn === 'skew') {\n        fnArray = skewArray;\n      }\n\n      for (let fnIndex = 0; fnIndex < fnLen; fnIndex += 1) {\n        const fnAxis = prepAxis[fnIndex];\n        fnArray[fnIndex] = (`${fn}${fnAxis}` in obj) ? parseInt(obj[`${fn}${fnAxis}`], 10) : 0;\n      }\n      transformObject[fnId] = fnArray;\n    } else if (x === 'rotate') { //  rotate\n      transformObject.rotate3d = [0, 0, pv];\n    } else { // scale | perspective\n      transformObject[x] = x === 'scale' ? parseFloat(obj[x]) : pv;\n    }\n  });\n\n  return transformObject;\n}\n\n/**\n * Prepare tween object in advance for `to()` method.\n * @param {string} tweenProp the property name\n */\nfunction crossCheckTransform(tweenProp) {\n  if (this.valuesEnd[tweenProp]) {\n    if (this.valuesEnd[tweenProp]) {\n      if (this.valuesEnd[tweenProp].perspective && !this.valuesStart[tweenProp].perspective) {\n        this.valuesStart[tweenProp].perspective = this.valuesEnd[tweenProp].perspective;\n      }\n    }\n  }\n}\n\n// All Component Functions\nconst transformFunctions = {\n  prepareStart: getTransform,\n  prepareProperty: prepareTransform,\n  onStart: onStartTransform,\n  crossCheck: crossCheckTransform,\n};\n\nconst supportedTransformProperties = [\n  'perspective',\n  'translate3d', 'translateX', 'translateY', 'translateZ', 'translate',\n  'rotate3d', 'rotateX', 'rotateY', 'rotateZ', 'rotate',\n  'skewX', 'skewY', 'skew',\n  'scale',\n];\n\nconst defaultTransformValues = {\n  perspective: 400,\n  translate3d: [0, 0, 0],\n  translateX: 0,\n  translateY: 0,\n  translateZ: 0,\n  translate: [0, 0],\n  rotate3d: [0, 0, 0],\n  rotateX: 0,\n  rotateY: 0,\n  rotateZ: 0,\n  rotate: 0,\n  skewX: 0,\n  skewY: 0,\n  skew: [0, 0],\n  scale: 1,\n};\n\n// Full Component\nconst TransformFunctions = {\n  component: 'transformFunctions',\n  property: 'transform',\n  subProperties: supportedTransformProperties,\n  defaultValues: defaultTransformValues,\n  functions: transformFunctions,\n  Interpolate: {\n    perspective,\n    translate3d,\n    rotate3d,\n    translate,\n    rotate,\n    scale,\n    skew,\n  },\n};\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartDraw(tweenProp) {\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n      const pathLength = (a.l * 100 >> 0) / 100;\n      const start = (numbers(a.s, b.s, v) * 100 >> 0) / 100;\n      const end = (numbers(a.e, b.e, v) * 100 >> 0) / 100;\n      const offset = 0 - start;\n      const dashOne = end + offset;\n      // eslint-disable-next-line no-param-reassign -- impossible to satisfy\n      elem.style.strokeDashoffset = `${offset}px`;\n      // eslint-disable-next-line no-param-reassign -- impossible to satisfy\n      elem.style.strokeDasharray = `${((dashOne < 1 ? 0 : dashOne) * 100 >> 0) / 100}px, ${pathLength}px`;\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n    };\n  }\n}\n\n// Component Util\n/**\n * Convert a `<path>` length percent value to absolute.\n * @param {string} v raw value\n * @param {number} l length value\n * @returns {number} the absolute value\n */\nfunction percent(v, l) {\n  return (parseFloat(v) / 100) * l;\n}\n\n/**\n * Returns the `<rect>` length.\n * It doesn't compute `rx` and / or `ry` of the element.\n * @see http://stackoverflow.com/a/30376660\n * @param {SVGRectElement} el target element\n * @returns {number} the `<rect>` length\n */\nfunction getRectLength(el) {\n  const w = el.getAttribute('width');\n  const h = el.getAttribute('height');\n  return (w * 2) + (h * 2);\n}\n\n/**\n * Returns the `<polyline>` / `<polygon>` length.\n * @param {SVGPolylineElement | SVGPolygonElement} el target element\n * @returns {number} the element length\n */\nfunction getPolyLength(el) {\n  const points = el.getAttribute('points').split(' ');\n\n  let len = 0;\n  if (points.length > 1) {\n    const coord = (p) => {\n      const c = p.split(',');\n      if (c.length !== 2) { return 0; } // return undefined\n      if (Number.isNaN(c[0] * 1) || Number.isNaN(c[1] * 1)) { return 0; }\n      return [parseFloat(c[0]), parseFloat(c[1])];\n    };\n\n    const dist = (c1, c2) => {\n      if (c1 !== undefined && c2 !== undefined) {\n        return Math.sqrt((c2[0] - c1[0]) ** 2 + (c2[1] - c1[1]) ** 2);\n      }\n      return 0;\n    };\n\n    if (points.length > 2) {\n      for (let i = 0; i < points.length - 1; i += 1) {\n        len += dist(coord(points[i]), coord(points[i + 1]));\n      }\n    }\n    len += el.tagName === 'polygon'\n      ? dist(coord(points[0]), coord(points[points.length - 1])) : 0;\n  }\n  return len;\n}\n\n/**\n * Returns the `<line>` length.\n * @param {SVGLineElement} el target element\n * @returns {number} the element length\n */\nfunction getLineLength(el) {\n  const x1 = el.getAttribute('x1');\n  const x2 = el.getAttribute('x2');\n  const y1 = el.getAttribute('y1');\n  const y2 = el.getAttribute('y2');\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n\n/**\n * Returns the `<circle>` length.\n * @param {SVGCircleElement} el target element\n * @returns {number} the element length\n */\nfunction getCircleLength(el) {\n  const r = el.getAttribute('r');\n  return 2 * Math.PI * r;\n}\n\n// returns the length of an ellipse\n/**\n * Returns the `<ellipse>` length.\n * @param {SVGEllipseElement} el target element\n * @returns {number} the element length\n */\nfunction getEllipseLength(el) {\n  const rx = el.getAttribute('rx');\n  const ry = el.getAttribute('ry');\n  const len = 2 * rx;\n  const wid = 2 * ry;\n  return ((Math.sqrt(0.5 * ((len * len) + (wid * wid)))) * (Math.PI * 2)) / 2;\n}\n\n/**\n * Returns the shape length.\n * @param {SVGPathCommander.shapeTypes} el target element\n * @returns {number} the element length\n */\nfunction getTotalLength$1(el) {\n  if (el.tagName === 'rect') {\n    return getRectLength(el);\n  } if (el.tagName === 'circle') {\n    return getCircleLength(el);\n  } if (el.tagName === 'ellipse') {\n    return getEllipseLength(el);\n  } if (['polygon', 'polyline'].includes(el.tagName)) {\n    return getPolyLength(el);\n  } if (el.tagName === 'line') {\n    return getLineLength(el);\n  }\n  // ESLint\n  return 0;\n}\n\n/**\n * Returns the property tween object.\n * @param {SVGPathCommander.shapeTypes} element the target element\n * @param {string | KUTE.drawObject} value the property value\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction getDraw(element, value) {\n  const length = /path|glyph/.test(element.tagName)\n    ? element.getTotalLength()\n    : getTotalLength$1(element);\n  let start;\n  let end;\n  let dasharray;\n  let offset;\n\n  if (value instanceof Object && Object.keys(value).every((v) => ['s', 'e', 'l'].includes(v))) {\n    return value;\n  } if (typeof value === 'string') {\n    const v = value.split(/,|\\s/);\n    start = /%/.test(v[0]) ? percent(v[0].trim(), length) : parseFloat(v[0]);\n    end = /%/.test(v[1]) ? percent(v[1].trim(), length) : parseFloat(v[1]);\n  } else if (typeof value === 'undefined') {\n    offset = parseFloat(getStyleForProperty(element, 'stroke-dashoffset'));\n    dasharray = getStyleForProperty(element, 'stroke-dasharray').split(',');\n\n    start = 0 - offset;\n    end = parseFloat(dasharray[0]) + start || length;\n  }\n  return { s: start, e: end, l: length };\n}\n\n/**\n * Reset CSS properties associated with the `draw` property.\n * @param {SVGPathCommander.shapeTypes} element target\n */\nfunction resetDraw(elem) {\n  /* eslint-disable no-param-reassign -- impossible to satisfy */\n  elem.style.strokeDashoffset = '';\n  elem.style.strokeDasharray = '';\n  /* eslint-disable no-param-reassign -- impossible to satisfy */\n}\n\n// Component Functions\n/**\n * Returns the property tween object.\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction getDrawValue(/* prop, value */) {\n  return getDraw(this.element);\n}\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string | KUTE.drawObject} value the property value\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction prepareDraw(_, value) {\n  return getDraw(this.element, value);\n}\n\n// All Component Functions\nconst svgDrawFunctions = {\n  prepareStart: getDrawValue,\n  prepareProperty: prepareDraw,\n  onStart: onStartDraw,\n};\n\n// Component Full\nconst SvgDrawProperty = {\n  component: 'svgDraw',\n  property: 'draw',\n  defaultValue: '0% 0%',\n  Interpolate: { numbers },\n  functions: svgDrawFunctions,\n  // Export to global for faster execution\n  Util: {\n    getRectLength,\n    getPolyLength,\n    getLineLength,\n    getCircleLength,\n    getEllipseLength,\n    getTotalLength: getTotalLength$1,\n    resetDraw,\n    getDraw,\n    percent,\n  },\n};\n\n/**\n * Splits an extended A (arc-to) segment into two cubic-bezier segments.\n *\n * @param {SVGPath.pathArray} path the `pathArray` this segment belongs to\n * @param {string[]} allPathCommands all previous path commands\n * @param {number} i the segment index\n */\n\nfunction fixArc(path, allPathCommands, i) {\n  if (path[i].length > 7) {\n    path[i].shift();\n    const segment = path[i];\n    let ni = i; // ESLint\n    while (segment.length) {\n      // if created multiple C:s, their original seg is saved\n      allPathCommands[i] = 'A';\n      path.splice(ni += 1, 0, ['C', ...segment.splice(0, 6)]);\n    }\n    path.splice(i, 1);\n  }\n}\n\n/**\n * Segment params length\n * @type {Record<string, number>}\n */\nconst paramsCount = {\n  a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0,\n};\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isPathArray(path) {\n  return Array.isArray(path) && path.every((seg) => {\n    const lk = seg[0].toLowerCase();\n    return paramsCount[lk] === seg.length - 1 && 'achlmqstvz'.includes(lk);\n  });\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isAbsoluteArray(path) {\n  return isPathArray(path)\n    // `isPathArray` also checks if it's `Array`\n    && path.every(([x]) => x === x.toUpperCase());\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isNormalizedArray(path) {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => 'ACLMQZ'.includes(pc));\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param {string | SVGPath.pathArray} path the `Array` to be checked\n * @returns {boolean} iteration result\n */\nfunction isCurveArray(path) {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => 'MC'.includes(pc));\n}\n\n/**\n * Returns a clone of an existing `pathArray`.\n *\n * @param {SVGPath.pathArray | SVGPath.pathSegment} path the source `pathArray`\n * @returns {any} the cloned `pathArray`\n */\nfunction clonePath(path) {\n  return path.map((x) => (Array.isArray(x) ? [...x] : x));\n}\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction finalizeSegment(path) {\n  let pathCommand = path.pathValue[path.segmentStart];\n  let LK = pathCommand.toLowerCase();\n  const { data } = path;\n\n  while (data.length >= paramsCount[LK]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (LK === 'm' && data.length > 2) {\n      path.segments.push([pathCommand, ...data.splice(0, 2)]);\n      LK = 'l';\n      pathCommand = pathCommand === 'm' ? 'l' : 'L';\n    } else {\n      path.segments.push([pathCommand, ...data.splice(0, paramsCount[LK])]);\n    }\n\n    if (!paramsCount[LK]) {\n      break;\n    }\n  }\n}\n\nconst error = 'SVGPathCommander error';\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanFlag(path) {\n  const { index, pathValue } = path;\n  const code = pathValue.charCodeAt(index);\n\n  if (code === 0x30/* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n\n  if (code === 0x31/* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n\n  path.err = `${error}: invalid Arc flag \"${pathValue[index]}\", expecting 0 or 1 at index ${index}`;\n}\n\n/**\n * Checks if a character is a digit.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isDigit(code) {\n  return (code >= 48 && code <= 57); // 0..9\n}\n\nconst invalidPathValue = 'Invalid path value';\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanParam(path) {\n  const { max, pathValue, index: start } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n\n  if (index >= max) {\n    // path.err = 'SvgPath: missed param (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n\n  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2E/* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" is not a number`;\n    return;\n  }\n\n  if (ch !== 0x2E/* . */) {\n    zeroFirst = (ch === 0x30/* 0 */);\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${pathValue[start]}\" illegal number`;\n        return;\n      }\n    }\n\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x2E/* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x65/* e */ || ch === 0x45/* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid float exponent`;\n      return;\n    }\n\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid integer exponent`;\n      return;\n    }\n  }\n\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n}\n\n/**\n * Checks if the character is a space.\n *\n * @param {number} ch the character to check\n * @returns {boolean} check result\n */\nfunction isSpace(ch) {\n  const specialSpaces = [\n    0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,\n    0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];\n  /* istanbul ignore next */\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) // Line terminators\n    // White spaces\n    || (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0)\n    || (ch >= 0x1680 && specialSpaces.includes(ch));\n}\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction skipSpaces(path) {\n  const { pathValue, max } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n}\n\n/**\n * Checks if the character is a path command.\n *\n * @param {any} code the character to check\n * @returns {boolean} check result\n */\nfunction isPathCommand(code) {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6D/* m */:\n    case 0x7A/* z */:\n    case 0x6C/* l */:\n    case 0x68/* h */:\n    case 0x76/* v */:\n    case 0x63/* c */:\n    case 0x73/* s */:\n    case 0x71/* q */:\n    case 0x74/* t */:\n    case 0x61/* a */:\n    // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isDigitStart(code) {\n  return (code >= 48 && code <= 57) /* 0..9 */\n    || code === 0x2B /* + */\n    || code === 0x2D /* - */\n    || code === 0x2E; /* . */\n}\n\n/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isArcCommand(code) {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n}\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanSegment(path) {\n  const { max, pathValue, index } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams = paramsCount[pathValue[index].toLowerCase()];\n\n  path.segmentStart = index;\n\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${pathValue[index]}\" is not a path command`;\n    return;\n  }\n\n  path.index += 1;\n  skipSpaces(path);\n\n  path.data = [];\n\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\n      else scanParam(path);\n\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (path.index < max && pathValue.charCodeAt(path.index) === 0x2C/* , */) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(path);\n}\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param {string} pathString\n */\nfunction PathParser(pathString) {\n  /** @type {SVGPath.pathArray} */\n  this.segments = [];\n  /** @type {string} */\n  this.pathValue = pathString;\n  /** @type {number} */\n  this.max = pathString.length;\n  /** @type {number} */\n  this.index = 0;\n  /** @type {number} */\n  this.param = 0.0;\n  /** @type {number} */\n  this.segmentStart = 0;\n  /** @type {any} */\n  this.data = [];\n  /** @type {string} */\n  this.err = '';\n}\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param {SVGPath.pathArray | string} pathInput the string to be parsed\n * @returns {SVGPath.pathArray | string} the resulted `pathArray` or error string\n */\nfunction parsePathString(pathInput) {\n  if (isPathArray(pathInput)) {\n    return clonePath(pathInput);\n  }\n\n  const path = new PathParser(pathInput);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  return path.err ? path.err : path.segments;\n}\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param {string | SVGPath.pathArray} pathInput the path string | object\n * @returns {SVGPath.absoluteArray} the resulted `pathArray` with absolute values\n */\nfunction pathToAbsolute(pathInput) {\n  /* istanbul ignore else */\n  if (isAbsoluteArray(pathInput)) {\n    // `isAbsoluteArray` checks if it's `pathArray`\n    return clonePath(pathInput);\n  }\n\n  const path = parsePathString(pathInput);\n  let x = 0; let y = 0;\n  let mx = 0; let my = 0;\n\n  // the `absoluteSegment[]` is for sure an `absolutePath`\n  return path.map((segment) => {\n    const values = segment.slice(1).map(Number);\n    const [pathCommand] = segment;\n    /** @type {SVGPath.absoluteCommand} */\n    const absCommand = pathCommand.toUpperCase();\n\n    if (pathCommand === 'M') {\n      [x, y] = values;\n      mx = x;\n      my = y;\n      return ['M', x, y];\n    }\n    /** @type {SVGPath.absoluteSegment} */\n    let absoluteSegment = [];\n\n    if (pathCommand !== absCommand) {\n      switch (absCommand) {\n        case 'A':\n          absoluteSegment = [\n            absCommand, values[0], values[1], values[2],\n            values[3], values[4], values[5] + x, values[6] + y];\n          break;\n        case 'V':\n          absoluteSegment = [absCommand, values[0] + y];\n          break;\n        case 'H':\n          absoluteSegment = [absCommand, values[0] + x];\n          break;\n        default: {\n          // use brakets for `eslint: no-case-declaration`\n          // https://stackoverflow.com/a/50753272/803358\n          const absValues = values.map((n, j) => n + (j % 2 ? y : x));\n          // for n, l, c, s, q, t\n          absoluteSegment = [absCommand, ...absValues];\n        }\n      }\n    } else {\n      absoluteSegment = [absCommand, ...values];\n    }\n\n    const segLength = absoluteSegment.length;\n    switch (absCommand) {\n      case 'Z':\n        x = mx;\n        y = my;\n        break;\n      case 'H':\n        [, x] = absoluteSegment;\n        break;\n      case 'V':\n        [, y] = absoluteSegment;\n        break;\n      default:\n        x = absoluteSegment[segLength - 2];\n        y = absoluteSegment[segLength - 1];\n\n        if (absCommand === 'M') {\n          mx = x;\n          my = y;\n        }\n    }\n    return absoluteSegment;\n  });\n}\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param {SVGPath.pathSegment} segment the segment object\n * @param {any} params the coordinates of the previous segment\n * @returns {SVGPath.normalSegment} the normalized segment\n */\nfunction normalizeSegment(segment, params) {\n  const [pathCommand] = segment;\n  const {\n    x1: px1, y1: py1, x2: px2, y2: py2,\n  } = params;\n  const values = segment.slice(1).map(Number);\n  let result = segment;\n\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === 'H') {\n    result = ['L', segment[1], py1];\n  } else if (pathCommand === 'V') {\n    result = ['L', px1, segment[1]];\n  } else if (pathCommand === 'S') {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    result = ['C', x1, y1, ...values];\n  } else if (pathCommand === 'T') {\n    const qx = px1 * 2 - params.qx;\n    const qy = py1 * 2 - params.qy;\n    params.qx = qx;\n    params.qy = qy;\n    result = ['Q', qx, qy, ...values];\n  } else if (pathCommand === 'Q') {\n    const [nqx, nqy] = values;\n    params.qx = nqx;\n    params.qy = nqy;\n  }\n\n  return result;\n}\n\n/**\n * @type {SVGPath.parserParams}\n */\nconst paramsParser = {\n  x1: 0, y1: 0, x2: 0, y2: 0, x: 0, y: 0, qx: null, qy: null,\n};\n\n/**\n * Normalizes a `path` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param {string | SVGPath.pathArray} pathInput the string to be parsed or 'pathArray'\n * @returns {SVGPath.normalArray} the normalized `pathArray`\n */\nfunction normalizePath(pathInput) {\n  if (isNormalizedArray(pathInput)) {\n    return clonePath(pathInput);\n  }\n\n  /** @type {SVGPath.normalArray} */\n  const path = pathToAbsolute(pathInput);\n  const params = { ...paramsParser };\n  const ii = path.length;\n\n  for (let i = 0; i < ii; i += 1) {\n    path[i];\n    path[i] = normalizeSegment(path[i], params);\n\n    const segment = path[i];\n    const seglen = segment.length;\n\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +(segment[seglen - 4]) || params.x1;\n    params.y2 = +(segment[seglen - 3]) || params.y1;\n  }\n\n  return path;\n}\n\n/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param {number} x the initial vector x\n * @param {number} y the initial vector y\n * @param {number} rad the radian vector angle\n * @returns {{x: number, y: number}} the rotated vector\n */\nfunction rotateVector(x, y, rad) {\n  const X = x * Math.cos(rad) - y * Math.sin(rad);\n  const Y = x * Math.sin(rad) + y * Math.cos(rad);\n  return { x: X, y: Y };\n}\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param {number} X1 the starting x position\n * @param {number} Y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} X2 the ending x position\n * @param {number} Y2 the ending y position\n * @param {number[]=} recursive the parameters needed to split arc into 2 segments\n * @return {number[]} the resulting cubic-bezier segment(s)\n */\nfunction arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {\n  let x1 = X1; let y1 = Y1; let rx = RX; let ry = RY; let x2 = X2; let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  /** @type {number[]} */\n  let res = [];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k = (LAF === SF ? -1 : 1)\n            * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x)\n                / (rx2 * y * y + ry2 * x * x)));\n\n    cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n    cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin((((y1 - cy) / ry) * (10 ** 9) >> 0) / (10 ** 9));\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin((((y2 - cy) / ry) * (10 ** 9) >> 0) / (10 ** 9));\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) (f1 = Math.PI * 2 + f1);\n    if (f2 < 0) (f2 = Math.PI * 2 + f2);\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [...m2, ...m3, ...m4, ...res];\n  }\n  res = [...m2, ...m3, ...m4, ...res];\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2\n      ? rotateVector(res[i - 1], res[i], rad).y\n      : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n}\n\n/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param {number} x1 curve start x\n * @param {number} y1 curve start y\n * @param {number} qx control point x\n * @param {number} qy control point y\n * @param {number} x2 curve end x\n * @param {number} y2 curve end y\n * @returns {number[]} the cubic-bezier segment\n */\nfunction quadToCubic(x1, y1, qx, qy, x2, y2) {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [\n    r13 * x1 + r23 * qx, // cpx1\n    r13 * y1 + r23 * qy, // cpy1\n    r13 * x2 + r23 * qx, // cpx2\n    r13 * y2 + r23 * qy, // cpy2\n    x2, y2, // x,y\n  ];\n}\n\n/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param {[number, number]} a the first point coordinates\n * @param {[number, number]} b the second point coordinates\n * @param {number} t the ratio\n * @returns {[number, number]} the midpoint coordinates\n */\nfunction midPoint(a, b, t) {\n  const [ax, ay] = a; const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n}\n\n/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param {[number, number]} a the first point coordinates\n * @param {[number, number]} b the second point coordinates\n * @returns {number} the distance value\n */\nfunction distanceSquareRoot(a, b) {\n  return Math.sqrt(\n    (a[0] - b[0]) * (a[0] - b[0])\n    + (a[1] - b[1]) * (a[1] - b[1]),\n  );\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a line (L,V,H,Z) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the distance to point\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentLineFactory(x1, y1, x2, y2, distance) {\n  const length = distanceSquareRoot([x1, y1], [x2, y2]);\n  let point = { x: 0, y: 0 };\n\n  /* istanbul ignore else */\n  if (typeof distance === 'number') {\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = { x, y };\n    }\n  }\n\n  return {\n    length,\n    point,\n    min: {\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n    },\n    max: {\n      x: Math.max(x1, x2),\n      y: Math.max(y1, y2),\n    },\n  };\n}\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param {number} x1 line start x\n * @param {number} y1 line start y\n * @param {number} x2 line end x\n * @param {number} y2 line end y\n * @returns {number[]} the cubic-bezier segment\n */\nfunction lineToCubic(x1, y1, x2, y2) {\n  const t = 0.5;\n  /** @type {[number, number]} */\n  const p0 = [x1, y1];\n  /** @type {[number, number]} */\n  const p1 = [x2, y2];\n  const p2 = midPoint(p0, p1, t);\n  const p3 = midPoint(p1, p2, t);\n  const p4 = midPoint(p2, p3, t);\n  const p5 = midPoint(p3, p4, t);\n  const p6 = midPoint(p4, p5, t);\n  const seg1 = [...p0, ...p2, ...p4, ...p6, t];\n  const cp1 = segmentLineFactory(...seg1).point;\n  const seg2 = [...p6, ...p5, ...p3, ...p1, 0];\n  const cp2 = segmentLineFactory(...seg2).point;\n\n  return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];\n}\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param {SVGPath.pathSegment} segment the source segment\n * @param {SVGPath.parserParams} params the source segment parameters\n * @returns {SVGPath.cubicSegment | SVGPath.MSegment} the cubic-bezier segment\n */\nfunction segmentToCubic(segment, params) {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  let args;\n  const {\n    x1: px1, y1: py1, x: px, y: py,\n  } = params;\n\n  if (!'TQ'.includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n\n  switch (pathCommand) {\n    case 'M':\n      params.x = x;\n      params.y = y;\n      return segment;\n    case 'A':\n      args = [px1, py1, ...values];\n      return ['C', ...arcToCubic(...args)];\n    case 'Q':\n      params.qx = x;\n      params.qy = y;\n      args = [px1, py1, ...values];\n      return ['C', ...quadToCubic(...args)];\n    case 'L':\n      return ['C', ...lineToCubic(px1, py1, x, y)];\n    case 'Z':\n      return ['C', ...lineToCubic(px1, py1, px, py)];\n  }\n  return segment;\n}\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param {string | SVGPath.pathArray} pathInput the string to be parsed or 'pathArray'\n * @returns {SVGPath.curveArray} the resulted `pathArray` converted to cubic-bezier\n */\nfunction pathToCurve(pathInput) {\n  /* istanbul ignore else */\n  if (isCurveArray(pathInput)) {\n    // `isCurveArray` checks if it's `pathArray`\n    return clonePath(pathInput);\n  }\n\n  // const path = fixPath(normalizePath(pathInput));\n  const path = normalizePath(pathInput);\n  const params = { ...paramsParser };\n  const allPathCommands = [];\n  let pathCommand = ''; // ts-lint\n  let ii = path.length;\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n    allPathCommands[i] = pathCommand;\n\n    path[i] = segmentToCubic(path[i], params);\n\n    fixArc(path, allPathCommands, i);\n    ii = path.length;\n\n    const segment = path[i];\n    const seglen = segment.length;\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +(segment[seglen - 4]) || params.x1;\n    params.y2 = +(segment[seglen - 3]) || params.y1;\n  }\n\n  return path;\n}\n\n/**\n * SVGPathCommander default options\n * @type {SVGPath.options}\n */\nconst defaultOptions = {\n  origin: [0, 0, 0],\n  round: 4,\n};\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param {SVGPath.pathArray} path the source `pathArray`\n * @param {number | 'off'} roundOption the amount of decimals to round numbers to\n * @returns {SVGPath.pathArray} the resulted `pathArray` with rounded values\n */\nfunction roundPath(path, roundOption) {\n  let { round } = defaultOptions;\n  if (roundOption === 'off' || round === 'off') return clonePath(path);\n  // round = roundOption >= 1 ? roundOption : round;\n  // allow for ZERO decimals\n  round = roundOption >= 0 ? roundOption : round;\n  // to round values to the power\n  // the `round` value must be integer\n  const pow = typeof round === 'number' && round >= 1 ? (10 ** round) : 1;\n\n  return path.map((pi) => {\n    const values = pi.slice(1).map(Number)\n      .map((n) => (round ? (Math.round(n * pow) / pow) : Math.round(n)));\n    return [pi[0], ...values];\n  });\n}\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param {SVGPath.pathArray} path the `pathArray` object\n * @param {number | 'off'} round amount of decimals to round values to\n * @returns {string} the concatenated path string\n */\nfunction pathToString(path, round) {\n  return roundPath(path, round)\n    .map((x) => x[0] + x.slice(1).join(' ')).join('');\n}\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param {SVGPath.pathArray} pathInput the source `pathArray`\n * @return {SVGPath.pathArray[]} an array with all sub-path strings\n */\nfunction splitPath(pathInput) {\n  /** @type {SVGPath.pathArray[]} */\n  const composite = [];\n  /** @type {SVGPath.pathArray} */\n  let path;\n  let pi = -1;\n\n  pathInput.forEach((seg) => {\n    if (seg[0] === 'M') {\n      path = [seg];\n      pi += 1;\n    } else {\n      path = [...path, seg];\n    }\n    composite[pi] = path;\n  });\n\n  return composite;\n}\n\n/**\n *\n * @param {{x: number, y: number}} v0\n * @param {{x: number, y: number}} v1\n * @returns {{x: number, y: number}}\n */\nfunction angleBetween(v0, v1) {\n  const { x: v0x, y: v0y } = v0;\n  const { x: v1x, y: v1y } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  const angle = sign * Math.acos(p / n);\n\n  return angle;\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.\n * @see https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n *\n * @param {number} x1 the starting x position\n * @param {number} y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} x the ending x position\n * @param {number} y the ending y position\n * @param {number} t the point distance\n * @returns {{x: number, y: number}} the requested point\n */\nfunction getPointAtArcSegmentLength(x1, y1, RX, RY, angle, LAF, SF, x, y, t) {\n  const {\n    abs, sin, cos, sqrt, PI,\n  } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = ((angle % 360) + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n\n  if (x1 === x && y1 === y) {\n    return { x: x1, y: y1 };\n  }\n\n  if (rx === 0 || ry === 0) {\n    return segmentLineFactory(x1, y1, x, y, t).point;\n  }\n\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\n  };\n\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 + transformedPoint.y ** 2 / ry ** 2;\n\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n\n  const cSquareNumerator = rx ** 2 * ry ** 2\n    - rx ** 2 * transformedPoint.y ** 2\n    - ry ** 2 * transformedPoint.x ** 2;\n\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2\n    + ry ** 2 * transformedPoint.x ** 2;\n\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * ((rx * transformedPoint.y) / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\n  };\n\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x\n      - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x\n      + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2,\n  };\n\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\n\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n\n  const alpha = startAngle + sweepAngle * t;\n  const ellipseComponentX = rx * cos(alpha);\n  const ellipseComponentY = ry * sin(alpha);\n\n  const point = {\n    x: cos(xRotRad) * ellipseComponentX\n      - sin(xRotRad) * ellipseComponentY\n      + center.x,\n    y: sin(xRotRad) * ellipseComponentX\n      + cos(xRotRad) * ellipseComponentY\n      + center.y,\n  };\n\n  // to be used later\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n\n  return point;\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the shape minimum and maximum {x,y} coordinates of an A (arc-to) segment.\n *\n * @param {number} X1 the starting x position\n * @param {number} Y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} X2 the ending x position\n * @param {number} Y2 the ending y position\n * @param {number} distance the point distance\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentArcFactory(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = X1; let y = Y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: X2, y: Y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map((n) => n.x)),\n      y: Math.min(...POINTS.map((n) => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map((n) => n.x)),\n      y: Math.max(...POINTS.map((n) => n.y)),\n    },\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} c1x the first control point X\n * @param {number} c1y the first control point Y\n * @param {number} c2x the second control point X\n * @param {number} c2y the second control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number} t a [0-1] ratio\n * @returns {{x: number, y: number}} the cubic-bezier segment length\n */\nfunction getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t) {\n  const t1 = 1 - t;\n  return {\n    x: (t1 ** 3) * x1\n      + 3 * (t1 ** 2) * t * c1x\n      + 3 * t1 * (t ** 2) * c2x\n      + (t ** 3) * x2,\n    y: (t1 ** 3) * y1\n      + 3 * (t1 ** 2) * t * c1y\n      + 3 * t1 * (t ** 2) * c2y\n      + (t ** 3) * y2,\n  };\n}\n\n/**\n * Returns the length of a C (cubic-bezier) segment\n * or an {x,y} point at a given length.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} c1x the first control point X\n * @param {number} c1y the first control point Y\n * @param {number} c2x the second control point X\n * @param {number} c2y the second control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the point distance\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = x1; let y = y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: x2, y: y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map((n) => n.x)),\n      y: Math.min(...POINTS.map((n) => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map((n) => n.x)),\n      y: Math.max(...POINTS.map((n) => n.y)),\n    },\n  };\n}\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} cx the control point X\n * @param {number} cy the control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number} t a [0-1] ratio\n * @returns {{x: number, y: number}} the requested {x,y} coordinates\n */\nfunction getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t) {\n  const t1 = 1 - t;\n  return {\n    x: (t1 ** 2) * x1\n      + 2 * t1 * t * cx\n      + (t ** 2) * x2,\n    y: (t1 ** 2) * y1\n      + 2 * t1 * t * cy\n      + (t ** 2) * y2,\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a Q (quadratic-bezier) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} qx the control point X\n * @param {number} qy the control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the distance to point\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = x1; let y = y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  /* istanbul ignore else */\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: x2, y: y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map((n) => n.x)),\n      y: Math.min(...POINTS.map((n) => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map((n) => n.x)),\n      y: Math.max(...POINTS.map((n) => n.y)),\n    },\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length\n * of a shape, the shape total length and\n * the shape minimum and maximum {x,y} coordinates.\n *\n * @param {string | SVGPath.pathArray} pathInput the `pathArray` to look into\n * @param {number=} distance the length of the shape to look at\n * @returns {SVGPath.lengthFactory} the path length, point, min & max\n */\nfunction pathLengthFactory(pathInput, distance) {\n  const path = normalizePath(pathInput);\n  const distanceIsNumber = typeof distance === 'number';\n  let isM;\n  let data = [];\n  let pathCommand;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let seg;\n  let MIN = [];\n  let MAX = [];\n  let length = 0;\n  let min = { x: 0, y: 0 };\n  let max = min;\n  let point = min;\n  let POINT = min;\n  let LENGTH = 0;\n\n  for (let i = 0, ll = path.length; i < ll; i += 1) {\n    seg = path[i];\n    [pathCommand] = seg;\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y, ...seg.slice(1)] : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg;\n      min = { x: mx, y: my };\n      max = min;\n      length = 0;\n\n      if (distanceIsNumber && distance < 0.001) {\n        POINT = min;\n      }\n    } else if (pathCommand === 'L') {\n      ({\n        length, min, max, point,\n      } = segmentLineFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'A') {\n      ({\n        length, min, max, point,\n      } = segmentArcFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'C') {\n      ({\n        length, min, max, point,\n      } = segmentCubicFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'Q') {\n      ({\n        length, min, max, point,\n      } = segmentQuadFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      ({\n        length, min, max, point,\n      } = segmentLineFactory(...data, (distance || 0) - LENGTH));\n    }\n\n    if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {\n      POINT = point;\n    }\n\n    MAX = [...MAX, max];\n    MIN = [...MIN, min];\n    LENGTH += length;\n\n    [x, y] = pathCommand !== 'Z' ? seg.slice(-2) : [mx, my];\n  }\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x, y };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...MIN.map((n) => n.x)),\n      y: Math.min(...MIN.map((n) => n.y)),\n    },\n    max: {\n      x: Math.max(...MAX.map((n) => n.x)),\n      y: Math.max(...MAX.map((n) => n.y)),\n    },\n  };\n}\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * The `normalizePath` version is lighter, faster, more efficient and more accurate\n * with paths that are not `curveArray`.\n *\n * @param {string | SVGPath.pathArray} pathInput the target `pathArray`\n * @returns {number} the shape total length\n */\nfunction getTotalLength(pathInput) {\n  return pathLengthFactory(pathInput).length;\n}\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param {string | SVGPath.pathArray} pathInput the `pathArray` to look into\n * @param {number} distance the length of the shape to look at\n * @returns {{x: number, y: number}} the requested {x, y} point coordinates\n */\nfunction getPointAtLength(pathInput, distance) {\n  return pathLengthFactory(pathInput, distance).point;\n}\n\n/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param {number[][]} polygon an array of coordinates\n * @returns {number} the polygon area\n */\nfunction polygonArea(polygon) {\n  const n = polygon.length;\n  let i = -1;\n  let a;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n}\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param {[number,number][]} polygon an array of coordinates\n * @returns {number} the polygon length\n */\nfunction polygonLength(polygon) {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n}\n\n/**\n * A global namespace for epsilon.\n *\n * @type {number}\n */\nconst epsilon = 1e-9;\n\n/**\n * Coordinates Interpolation Function.\n *\n * @param {number[][]} a start coordinates\n * @param {number[][]} b end coordinates\n * @param {string} l amount of coordinates\n * @param {number} v progress\n * @returns {number[][]} the interpolated coordinates\n */\nfunction coords(a, b, l, v) {\n  const points = [];\n  for (let i = 0; i < l; i += 1) { // for each point\n    points[i] = [];\n    for (let j = 0; j < 2; j += 1) { // each point coordinate\n      // eslint-disable-next-line no-bitwise\n      points[i].push(((a[i][j] + (b[i][j] - a[i][j]) * v) * 1000 >> 0) / 1000);\n    }\n  }\n  return points;\n}\n\n/* SVGMorph = {\n  property: 'path',\n  defaultValue: [],\n  interpolators: {numbers,coords} },\n  functions = { prepareStart, prepareProperty, onStart, crossCheck }\n} */\n\n// Component functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartSVGMorph(tweenProp) {\n  if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      const path1 = a.polygon; const path2 = b.polygon;\n      const len = path2.length;\n      elem.setAttribute('d', (v === 1 ? b.original : `M${coords(path1, path2, len, v).join('L')}Z`));\n    };\n  }\n}\n\n// Component Util\n// original script flubber\n// https://github.com/veltman/flubber\n\n/**\n * Returns an existing polygon or false if it's not a polygon.\n * @param {SVGPath.pathArray} pathArray target `pathArray`\n * @returns {KUTE.exactPolygon | false} the resulted polygon\n */\nfunction exactPolygon(pathArray) {\n  const polygon = [];\n  const pathlen = pathArray.length;\n  let segment = [];\n  let pathCommand = '';\n\n  if (!pathArray.length || pathArray[0][0] !== 'M') {\n    return false;\n  }\n\n  for (let i = 0; i < pathlen; i += 1) {\n    segment = pathArray[i];\n    [pathCommand] = segment;\n\n    if ((pathCommand === 'M' && i) || pathCommand === 'Z') {\n      break; // !!\n    } else if ('ML'.includes(pathCommand)) {\n      polygon.push([segment[1], segment[2]]);\n    } else {\n      return false;\n    }\n  }\n\n  return pathlen ? { polygon } : false;\n}\n\n/**\n * Returns a new polygon polygon.\n * @param {SVGPath.pathArray} parsed target `pathArray`\n * @param {number} maxLength the maximum segment length\n * @returns {KUTE.exactPolygon} the resulted polygon\n */\nfunction approximatePolygon(parsed, maxLength) {\n  const ringPath = splitPath(parsed)[0];\n  const normalPath = normalizePath(ringPath);\n  const pathLength = getTotalLength(normalPath);\n  const polygon = [];\n  let numPoints = 3;\n  let point;\n\n  if (maxLength && !Number.isNaN(maxLength) && +maxLength > 0) {\n    numPoints = Math.max(numPoints, Math.ceil(pathLength / maxLength));\n  }\n\n  for (let i = 0; i < numPoints; i += 1) {\n    point = getPointAtLength(normalPath, (pathLength * i) / numPoints);\n    polygon.push([point.x, point.y]);\n  }\n\n  // Make all rings clockwise\n  if (polygonArea(polygon) > 0) {\n    polygon.reverse();\n  }\n\n  return {\n    polygon,\n    skipBisect: true,\n  };\n}\n\n/**\n * Parses a path string and returns a polygon array.\n * @param {string} str path string\n * @param {number} maxLength maximum amount of points\n * @returns {KUTE.exactPolygon} the polygon array we need\n */\nfunction pathStringToPolygon(str, maxLength) {\n  const parsed = normalizePath(str);\n  return exactPolygon(parsed) || approximatePolygon(parsed, maxLength);\n}\n\n/**\n * Rotates a polygon to better match its pair.\n * @param {KUTE.polygonMorph} polygon the target polygon\n * @param {KUTE.polygonMorph} vs the reference polygon\n */\nfunction rotatePolygon(polygon, vs) {\n  const len = polygon.length;\n  let min = Infinity;\n  let bestOffset;\n  let sumOfSquares = 0;\n  let spliced;\n  let d;\n  let p;\n\n  for (let offset = 0; offset < len; offset += 1) {\n    sumOfSquares = 0;\n\n    for (let i = 0; i < vs.length; i += 1) {\n      p = vs[i];\n      d = distanceSquareRoot(polygon[(offset + i) % len], p);\n      sumOfSquares += d * d;\n    }\n\n    if (sumOfSquares < min) {\n      min = sumOfSquares;\n      bestOffset = offset;\n    }\n  }\n\n  if (bestOffset) {\n    spliced = polygon.splice(0, bestOffset);\n    polygon.splice(polygon.length, 0, ...spliced);\n  }\n}\n\n/**\n * Sample additional points for a polygon to better match its pair.\n * @param {KUTE.polygonObject} polygon the target polygon\n * @param {number} numPoints the amount of points needed\n */\nfunction addPoints(polygon, numPoints) {\n  const desiredLength = polygon.length + numPoints;\n  const step = polygonLength(polygon) / numPoints;\n\n  let i = 0;\n  let cursor = 0;\n  let insertAt = step / 2;\n  let a;\n  let b;\n  let segment;\n\n  while (polygon.length < desiredLength) {\n    a = polygon[i];\n    b = polygon[(i + 1) % polygon.length];\n\n    segment = distanceSquareRoot(a, b);\n\n    if (insertAt <= cursor + segment) {\n      polygon.splice(i + 1, 0, segment\n        ? midPoint(a, b, (insertAt - cursor) / segment)\n        : a.slice(0));\n      insertAt += step;\n    } else {\n      cursor += segment;\n      i += 1;\n    }\n  }\n}\n\n/**\n * Split segments of a polygon until it reaches a certain\n * amount of points.\n * @param {number[][]} polygon the target polygon\n * @param {number} maxSegmentLength the maximum amount of points\n */\nfunction bisect(polygon, maxSegmentLength = Infinity) {\n  let a = [];\n  let b = [];\n\n  for (let i = 0; i < polygon.length; i += 1) {\n    a = polygon[i];\n    b = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n\n    // Could splice the whole set for a segment instead, but a bit messy\n    while (distanceSquareRoot(a, b) > maxSegmentLength) {\n      b = midPoint(a, b, 0.5);\n      polygon.splice(i + 1, 0, b);\n    }\n  }\n}\n\n/**\n * Checks the validity of a polygon.\n * @param {KUTE.polygonMorph} polygon the target polygon\n * @returns {boolean} the result of the check\n */\nfunction validPolygon(polygon) {\n  return Array.isArray(polygon)\n    && polygon.every((point) => Array.isArray(point)\n      && point.length === 2\n      && !Number.isNaN(point[0])\n      && !Number.isNaN(point[1]));\n}\n\n/**\n * Returns a new polygon and its length from string or another `Array`.\n * @param {KUTE.polygonMorph | string} input the target polygon\n * @param {number} maxSegmentLength the maximum amount of points\n * @returns {KUTE.polygonMorph} normalized polygon\n */\nfunction getPolygon(input, maxSegmentLength) {\n  let skipBisect;\n  let polygon;\n\n  if (typeof (input) === 'string') {\n    const converted = pathStringToPolygon(input, maxSegmentLength);\n    ({ polygon, skipBisect } = converted);\n  } else if (!Array.isArray(input)) {\n    throw Error(`${invalidPathValue}: ${input}`);\n  }\n\n  /** @type {KUTE.polygonMorph} */\n  const points = [...polygon];\n\n  if (!validPolygon(points)) {\n    throw Error(`${invalidPathValue}: ${points}`);\n  }\n\n  // TODO skip this test to avoid scale issues?\n  // Chosen epsilon (1e-6) is problematic for small coordinate range, we now use 1e-9\n  if (points.length > 1 && distanceSquareRoot(points[0], points[points.length - 1]) < epsilon) {\n    points.pop();\n  }\n\n  if (!skipBisect && maxSegmentLength\n    && !Number.isNaN(maxSegmentLength) && (+maxSegmentLength) > 0) {\n    bisect(points, maxSegmentLength);\n  }\n\n  return points;\n}\n\n/**\n * Returns two new polygons ready to tween.\n * @param {string} path1 the first path string\n * @param {string} path2 the second path string\n * @param {number} precision the morphPrecision option value\n * @returns {KUTE.polygonMorph[]} the two polygons\n */\nfunction getInterpolationPoints(path1, path2, precision) {\n  const morphPrecision = precision || defaultOptions$1.morphPrecision;\n  const fromRing = getPolygon(path1, morphPrecision);\n  const toRing = getPolygon(path2, morphPrecision);\n  const diff = fromRing.length - toRing.length;\n\n  addPoints(fromRing, diff < 0 ? diff * -1 : 0);\n  addPoints(toRing, diff > 0 ? diff : 0);\n\n  rotatePolygon(fromRing, toRing);\n\n  return [roundPath(fromRing), roundPath(toRing)];\n}\n\n// Component functions\n/**\n * Returns the current `d` attribute value.\n * @returns {string} the `d` attribute value\n */\nfunction getSVGMorph(/* tweenProp */) {\n  return this.element.getAttribute('d');\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string | KUTE.polygonObject} value the property value\n * @returns {KUTE.polygonObject} the property tween object\n */\nfunction prepareSVGMorph(/* tweenProp */_, value) {\n  const pathObject = {};\n  // remove newlines, they brake JSON strings sometimes\n  const pathReg = new RegExp('\\\\n', 'ig');\n  let elem = null;\n\n  if (value instanceof SVGPathElement) {\n    elem = value;\n  } else if (/^\\.|^#/.test(value)) {\n    elem = selector(value);\n  }\n\n  // first make sure we return pre-processed values\n  if (typeof (value) === 'object' && value.polygon) {\n    return value;\n  } if (elem && ['path', 'glyph'].includes(elem.tagName)) {\n    pathObject.original = elem.getAttribute('d').replace(pathReg, '');\n  // maybe it's a string path already\n  } else if (!elem && typeof (value) === 'string') {\n    pathObject.original = value.replace(pathReg, '');\n  }\n\n  return pathObject;\n}\n\n/**\n * Enables the `to()` method by preparing the tween object in advance.\n * @param {string} prop the `path` property name\n */\nfunction crossCheckSVGMorph(prop) {\n  if (this.valuesEnd[prop]) {\n    const pathArray1 = this.valuesStart[prop].polygon;\n    const pathArray2 = this.valuesEnd[prop].polygon;\n    // skip already processed paths\n    // allow the component to work with pre-processed values\n    if (!pathArray1 || !pathArray2 || (pathArray1.length !== pathArray2.length)) {\n      const p1 = this.valuesStart[prop].original;\n      const p2 = this.valuesEnd[prop].original;\n      // process morphPrecision\n      const morphPrecision = this._morphPrecision\n        ? parseInt(this._morphPrecision, 10)\n        : defaultOptions$1.morphPrecision;\n\n      const [path1, path2] = getInterpolationPoints(p1, p2, morphPrecision);\n      this.valuesStart[prop].polygon = path1;\n      this.valuesEnd[prop].polygon = path2;\n    }\n  }\n}\n\n// All Component Functions\nconst svgMorphFunctions = {\n  prepareStart: getSVGMorph,\n  prepareProperty: prepareSVGMorph,\n  onStart: onStartSVGMorph,\n  crossCheck: crossCheckSVGMorph,\n};\n\n// Component Full\nconst SVGMorph = {\n  component: 'svgMorph',\n  property: 'path',\n  defaultValue: [],\n  Interpolate: coords,\n  defaultOptions: { morphPrecision: 10 },\n  functions: svgMorphFunctions,\n  // Export utils to global for faster execution\n  Util: {\n    // component\n    addPoints,\n    bisect,\n    getPolygon,\n    validPolygon,\n    getInterpolationPoints,\n    pathStringToPolygon,\n    distanceSquareRoot,\n    midPoint,\n    approximatePolygon,\n    rotatePolygon,\n    // svg-path-commander\n    pathToString,\n    pathToCurve,\n    getTotalLength,\n    getPointAtLength,\n    polygonArea,\n    roundPath,\n  },\n};\n\nconst Components = {\n  EssentialBoxModel: BoxModelEssential,\n  ColorsProperties: colorProperties,\n  HTMLAttributes: htmlAttributes,\n  OpacityProperty,\n  TextWriteProp: TextWrite,\n  TransformFunctions,\n  SVGDraw: SvgDrawProperty,\n  SVGMorph,\n};\n\n// init components\nObject.keys(Components).forEach((component) => {\n  const compOps = Components[component];\n  Components[component] = new Animation(compOps);\n});\n\nvar version = \"2.2.4\";\n\n// @ts-ignore\n\n/**\n * A global namespace for library version.\n * @type {string}\n */\nconst Version = version;\n\n// KUTE.js standard distribution version\n\nconst KUTE = {\n  Animation,\n  Components,\n\n  // Tween Interface\n  Tween,\n  fromTo,\n  to,\n  // Tween Collection\n  TweenCollection,\n  allFromTo,\n  allTo,\n  // Tween Interface\n\n  Objects,\n  Util,\n  Easing,\n  CubicBezier,\n  Render,\n  Interpolate: interpolate,\n  Process,\n  Internals: internals,\n  Selector: selector,\n  Version,\n};\n\nexport { KUTE as default };\n"],
  "mappings": "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",
  "names": ["epsilon", "TweenConstructor", "ComponentName", "onComplete"]
}

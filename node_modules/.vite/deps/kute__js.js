import "./chunk-PZ5AY32C.js";

// node_modules/.deno/kute.js@2.2.4/node_modules/kute.js/dist/kute.esm.js
var CubicBezier = class {
  /**
   * @constructor
   * @param {number} x1 - first point horizontal position
   * @param {number} y1 - first point vertical position
   * @param {number} x2 - second point horizontal position
   * @param {number} y2 - second point vertical position
   * @param {string=} functionName - an optional function name
   * @returns {(t: number) => number} a new CubicBezier easing function
   */
  constructor(x1, y1, x2, y2, functionName) {
    const p1x = x1 || 0;
    const p1y = y1 || 0;
    const p2x = x2 || 1;
    const p2y = y2 || 1;
    this.cx = 3 * p1x;
    this.bx = 3 * (p2x - p1x) - this.cx;
    this.ax = 1 - this.cx - this.bx;
    this.cy = 3 * p1y;
    this.by = 3 * (p2y - p1y) - this.cy;
    this.ay = 1 - this.cy - this.by;
    const BezierEasing = (t) => this.sampleCurveY(this.solveCurveX(t));
    Object.defineProperty(BezierEasing, "name", { writable: true });
    BezierEasing.name = functionName || `cubic-bezier(${[p1x, p1y, p2x, p2y]})`;
    return BezierEasing;
  }
  /**
   * @param {number} t - progress [0-1]
   * @return {number} - sampled X value
   */
  sampleCurveX(t) {
    return ((this.ax * t + this.bx) * t + this.cx) * t;
  }
  /**
   * @param {number} t - progress [0-1]
   * @return {number} - sampled Y value
   */
  sampleCurveY(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
  }
  /**
   * @param {number} t - progress [0-1]
   * @return {number} - sampled curve derivative X value
   */
  sampleCurveDerivativeX(t) {
    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
  }
  /**
   * @param {number} x - progress [0-1]
   * @return {number} - solved curve X value
   */
  solveCurveX(x) {
    const epsilon2 = 1e-6;
    if (x <= 0) return 0;
    if (x >= 1) return 1;
    let t2 = x;
    let x2 = 0;
    let d2 = 0;
    for (let i = 0; i < 8; i += 1) {
      x2 = this.sampleCurveX(t2) - x;
      if (Math.abs(x2) < epsilon2) return t2;
      d2 = this.sampleCurveDerivativeX(t2);
      if (Math.abs(d2) < epsilon2) break;
      t2 -= x2 / d2;
    }
    let t0 = 0;
    let t1 = 1;
    t2 = x;
    while (t0 < t1) {
      x2 = this.sampleCurveX(t2);
      if (Math.abs(x2 - x) < epsilon2) return t2;
      if (x > x2) t0 = t2;
      else t1 = t2;
      t2 = (t1 - t0) * 0.5 + t0;
    }
    return t2;
  }
};
var version$1 = "1.0.1";
var Version$1 = version$1;
Object.assign(CubicBezier, { Version: Version$1 });
var KEC = {};
var Tweens = [];
var gl0bal;
if (typeof global !== "undefined") gl0bal = global;
else if (typeof window !== "undefined") gl0bal = window.self;
else gl0bal = {};
var globalObject = gl0bal;
var interpolate = {};
var onStart = {};
var performanceNow;
if (typeof self === "undefined" && typeof process !== "undefined" && process.hrtime) {
  performanceNow = () => {
    const time = process.hrtime();
    return time[0] * 1e3 + time[1] / 1e6;
  };
} else if (typeof self !== "undefined" && self.performance !== void 0 && self.performance.now !== void 0) {
  performanceNow = self.performance.now.bind(self.performance);
} else if (typeof Date !== "undefined" && Date.now) {
  performanceNow = Date.now;
} else {
  performanceNow = () => (/* @__PURE__ */ new Date()).getTime();
}
var now = performanceNow;
var Time = {};
Time.now = now;
var Tick = 0;
var Ticker = (time) => {
  let i = 0;
  while (i < Tweens.length) {
    if (Tweens[i].update(time)) {
      i += 1;
    } else {
      Tweens.splice(i, 1);
    }
  }
  Tick = requestAnimationFrame(Ticker);
};
function stop() {
  setTimeout(() => {
    if (!Tweens.length && Tick) {
      cancelAnimationFrame(Tick);
      Tick = null;
      Object.keys(onStart).forEach((obj) => {
        if (typeof onStart[obj] === "function") {
          if (KEC[obj]) delete KEC[obj];
        } else {
          Object.keys(onStart[obj]).forEach((prop) => {
            if (KEC[prop]) delete KEC[prop];
          });
        }
      });
      Object.keys(interpolate).forEach((i) => {
        if (KEC[i]) delete KEC[i];
      });
    }
  }, 64);
}
var Render = {
  Tick,
  Ticker,
  Tweens,
  Time
};
Object.keys(Render).forEach((blob) => {
  if (!KEC[blob]) {
    KEC[blob] = blob === "Time" ? Time.now : Render[blob];
  }
});
globalObject._KUTE = KEC;
var supportedProperties = {};
var defaultValues = {};
var defaultOptions$1 = {
  duration: 700,
  delay: 0,
  easing: "linear",
  repeat: 0,
  repeatDelay: 0,
  yoyo: false,
  resetStart: false,
  offset: 0
};
var prepareProperty = {};
var prepareStart = {};
var crossCheck = {};
var onComplete = {};
var linkProperty = {};
var Objects = {
  supportedProperties,
  defaultValues,
  defaultOptions: defaultOptions$1,
  prepareProperty,
  prepareStart,
  crossCheck,
  onStart,
  onComplete,
  linkProperty
};
var Util = {};
var add = (tw) => Tweens.push(tw);
var remove = (tw) => {
  const i = Tweens.indexOf(tw);
  if (i !== -1) Tweens.splice(i, 1);
};
var getAll = () => Tweens;
var removeAll = () => {
  Tweens.length = 0;
};
function linkInterpolation() {
  Object.keys(linkProperty).forEach((component) => {
    const componentLink = linkProperty[component];
    const componentProps = supportedProperties[component];
    Object.keys(componentLink).forEach((fnObj) => {
      if (typeof componentLink[fnObj] === "function" && Object.keys(this.valuesEnd).some((i) => componentProps && componentProps.includes(i) || i === "attr" && Object.keys(this.valuesEnd[i]).some((j) => componentProps && componentProps.includes(j)))) {
        if (!KEC[fnObj]) KEC[fnObj] = componentLink[fnObj];
      } else {
        Object.keys(this.valuesEnd).forEach((prop) => {
          const propObject = this.valuesEnd[prop];
          if (propObject instanceof Object) {
            Object.keys(propObject).forEach((i) => {
              if (typeof componentLink[i] === "function") {
                if (!KEC[i]) KEC[i] = componentLink[i];
              } else {
                Object.keys(componentLink[fnObj]).forEach((j) => {
                  if (componentLink[i] && typeof componentLink[i][j] === "function") {
                    if (!KEC[j]) KEC[j] = componentLink[i][j];
                  }
                });
              }
            });
          }
        });
      }
    });
  });
}
var internals = {
  add,
  remove,
  getAll,
  removeAll,
  stop,
  linkInterpolation
};
function getInlineStyle(el) {
  if (!el.style) return false;
  const css = el.style.cssText.replace(/\s/g, "").split(";");
  const transformObject = {};
  const arrayFn = ["translate3d", "translate", "scale3d", "skew"];
  css.forEach((cs) => {
    if (/transform/i.test(cs)) {
      const tps = cs.split(":")[1].split(")");
      tps.forEach((tpi) => {
        const tpv = tpi.split("(");
        const tp = tpv[0];
        const tv = tpv[1];
        if (!/matrix/.test(tp)) {
          transformObject[tp] = arrayFn.includes(tp) ? tv.split(",") : tv;
        }
      });
    }
  });
  return transformObject;
}
function getStyleForProperty(elem, propertyName) {
  let result = defaultValues[propertyName];
  const styleAttribute = elem.style;
  const computedStyle = getComputedStyle(elem) || elem.currentStyle;
  const styleValue = styleAttribute[propertyName] && !/auto|initial|none|unset/.test(styleAttribute[propertyName]) ? styleAttribute[propertyName] : computedStyle[propertyName];
  if (propertyName !== "transform" && (propertyName in computedStyle || propertyName in styleAttribute)) {
    result = styleValue;
  }
  return result;
}
function prepareObject(obj, fn) {
  const propertiesObject = fn === "start" ? this.valuesStart : this.valuesEnd;
  Object.keys(prepareProperty).forEach((component) => {
    const prepareComponent = prepareProperty[component];
    const supportComponent = supportedProperties[component];
    Object.keys(prepareComponent).forEach((tweenCategory) => {
      const transformObject = {};
      Object.keys(obj).forEach((tweenProp) => {
        if (defaultValues[tweenProp] && prepareComponent[tweenProp]) {
          propertiesObject[tweenProp] = prepareComponent[tweenProp].call(this, tweenProp, obj[tweenProp]);
        } else if (!defaultValues[tweenCategory] && tweenCategory === "transform" && supportComponent.includes(tweenProp)) {
          transformObject[tweenProp] = obj[tweenProp];
        } else if (!defaultValues[tweenProp] && tweenProp === "transform") {
          propertiesObject[tweenProp] = obj[tweenProp];
        } else if (!defaultValues[tweenCategory] && supportComponent && supportComponent.includes(tweenProp)) {
          propertiesObject[tweenProp] = prepareComponent[tweenCategory].call(this, tweenProp, obj[tweenProp]);
        }
      });
      if (Object.keys(transformObject).length) {
        propertiesObject[tweenCategory] = prepareComponent[tweenCategory].call(this, tweenCategory, transformObject);
      }
    });
  });
}
function getStartValues() {
  const startValues = {};
  const currentStyle = getInlineStyle(this.element);
  Object.keys(this.valuesStart).forEach((tweenProp) => {
    Object.keys(prepareStart).forEach((component) => {
      const componentStart = prepareStart[component];
      Object.keys(componentStart).forEach((tweenCategory) => {
        if (tweenCategory === tweenProp && componentStart[tweenProp]) {
          startValues[tweenProp] = componentStart[tweenCategory].call(this, tweenProp, this.valuesStart[tweenProp]);
        } else if (supportedProperties[component] && supportedProperties[component].includes(tweenProp)) {
          startValues[tweenProp] = componentStart[tweenCategory].call(this, tweenProp, this.valuesStart[tweenProp]);
        }
      });
    });
  });
  Object.keys(currentStyle).forEach((current) => {
    if (!(current in this.valuesStart)) {
      startValues[current] = currentStyle[current] || defaultValues[current];
    }
  });
  this.valuesStart = {};
  prepareObject.call(this, startValues, "start");
}
var Process = {
  getInlineStyle,
  getStyleForProperty,
  getStartValues,
  prepareObject
};
var connect = {};
connect.tween = null;
connect.processEasing = null;
var Easing = {
  linear: new CubicBezier(0, 0, 1, 1, "linear"),
  easingSinusoidalIn: new CubicBezier(0.47, 0, 0.745, 0.715, "easingSinusoidalIn"),
  easingSinusoidalOut: new CubicBezier(0.39, 0.575, 0.565, 1, "easingSinusoidalOut"),
  easingSinusoidalInOut: new CubicBezier(0.445, 0.05, 0.55, 0.95, "easingSinusoidalInOut"),
  easingQuadraticIn: new CubicBezier(0.55, 0.085, 0.68, 0.53, "easingQuadraticIn"),
  easingQuadraticOut: new CubicBezier(0.25, 0.46, 0.45, 0.94, "easingQuadraticOut"),
  easingQuadraticInOut: new CubicBezier(0.455, 0.03, 0.515, 0.955, "easingQuadraticInOut"),
  easingCubicIn: new CubicBezier(0.55, 0.055, 0.675, 0.19, "easingCubicIn"),
  easingCubicOut: new CubicBezier(0.215, 0.61, 0.355, 1, "easingCubicOut"),
  easingCubicInOut: new CubicBezier(0.645, 0.045, 0.355, 1, "easingCubicInOut"),
  easingQuarticIn: new CubicBezier(0.895, 0.03, 0.685, 0.22, "easingQuarticIn"),
  easingQuarticOut: new CubicBezier(0.165, 0.84, 0.44, 1, "easingQuarticOut"),
  easingQuarticInOut: new CubicBezier(0.77, 0, 0.175, 1, "easingQuarticInOut"),
  easingQuinticIn: new CubicBezier(0.755, 0.05, 0.855, 0.06, "easingQuinticIn"),
  easingQuinticOut: new CubicBezier(0.23, 1, 0.32, 1, "easingQuinticOut"),
  easingQuinticInOut: new CubicBezier(0.86, 0, 0.07, 1, "easingQuinticInOut"),
  easingExponentialIn: new CubicBezier(0.95, 0.05, 0.795, 0.035, "easingExponentialIn"),
  easingExponentialOut: new CubicBezier(0.19, 1, 0.22, 1, "easingExponentialOut"),
  easingExponentialInOut: new CubicBezier(1, 0, 0, 1, "easingExponentialInOut"),
  easingCircularIn: new CubicBezier(0.6, 0.04, 0.98, 0.335, "easingCircularIn"),
  easingCircularOut: new CubicBezier(0.075, 0.82, 0.165, 1, "easingCircularOut"),
  easingCircularInOut: new CubicBezier(0.785, 0.135, 0.15, 0.86, "easingCircularInOut"),
  easingBackIn: new CubicBezier(0.6, -0.28, 0.735, 0.045, "easingBackIn"),
  easingBackOut: new CubicBezier(0.175, 0.885, 0.32, 1.275, "easingBackOut"),
  easingBackInOut: new CubicBezier(0.68, -0.55, 0.265, 1.55, "easingBackInOut")
};
function processBezierEasing(fn) {
  if (typeof fn === "function") {
    return fn;
  }
  if (typeof Easing[fn] === "function") {
    return Easing[fn];
  }
  if (/bezier/.test(fn)) {
    const bz = fn.replace(/bezier|\s|\(|\)/g, "").split(",");
    return new CubicBezier(bz[0] * 1, bz[1] * 1, bz[2] * 1, bz[3] * 1);
  }
  return Easing.linear;
}
connect.processEasing = processBezierEasing;
function selector(el, multi) {
  try {
    let requestedElem;
    let itemsArray;
    if (multi) {
      itemsArray = el instanceof Array && el.every((x) => x instanceof Element);
      requestedElem = el instanceof HTMLCollection || el instanceof NodeList || itemsArray ? el : document.querySelectorAll(el);
    } else {
      requestedElem = el instanceof Element || el === window ? el : document.querySelector(el);
    }
    return requestedElem;
  } catch (e) {
    throw TypeError(`KUTE.js - Element(s) not found: ${el}.`);
  }
}
function queueStart() {
  Object.keys(onStart).forEach((obj) => {
    if (typeof onStart[obj] === "function") {
      onStart[obj].call(this, obj);
    } else {
      Object.keys(onStart[obj]).forEach((prop) => {
        onStart[obj][prop].call(this, prop);
      });
    }
  });
  linkInterpolation.call(this);
}
var TweenBase = class {
  /**
   * @param {Element} targetElement the target element
   * @param {KUTE.tweenProps} startObject the start values
   * @param {KUTE.tweenProps} endObject the end values
   * @param {KUTE.tweenOptions} opsObject the end values
   * @returns {TweenBase} the resulting Tween object
   */
  constructor(targetElement, startObject, endObject, opsObject) {
    this.element = targetElement;
    this.playing = false;
    this._startTime = null;
    this._startFired = false;
    this.valuesEnd = endObject;
    this.valuesStart = startObject;
    const options = opsObject || {};
    this._resetStart = options.resetStart || 0;
    this._easing = typeof options.easing === "function" ? options.easing : connect.processEasing(options.easing);
    this._duration = options.duration || defaultOptions$1.duration;
    this._delay = options.delay || defaultOptions$1.delay;
    Object.keys(options).forEach((op) => {
      const internalOption = `_${op}`;
      if (!(internalOption in this)) this[internalOption] = options[op];
    });
    const easingFnName = this._easing.name;
    if (!onStart[easingFnName]) {
      onStart[easingFnName] = function easingFn(prop) {
        if (!KEC[prop] && prop === this._easing.name) KEC[prop] = this._easing;
      };
    }
    return this;
  }
  /**
   * Starts tweening
   * @param {number?} time the tween start time
   * @returns {TweenBase} this instance
   */
  start(time) {
    add(this);
    this.playing = true;
    this._startTime = typeof time !== "undefined" ? time : KEC.Time();
    this._startTime += this._delay;
    if (!this._startFired) {
      if (this._onStart) {
        this._onStart.call(this);
      }
      queueStart.call(this);
      this._startFired = true;
    }
    if (!Tick) Ticker();
    return this;
  }
  /**
   * Stops tweening
   * @returns {TweenBase} this instance
   */
  stop() {
    if (this.playing) {
      remove(this);
      this.playing = false;
      if (this._onStop) {
        this._onStop.call(this);
      }
      this.close();
    }
    return this;
  }
  /**
   * Trigger internal completion callbacks.
   */
  close() {
    Object.keys(onComplete).forEach((component) => {
      Object.keys(onComplete[component]).forEach((toClose) => {
        onComplete[component][toClose].call(this, toClose);
      });
    });
    this._startFired = false;
    stop.call(this);
  }
  /**
   * Schedule another tween instance to start once this one completes.
   * @param {KUTE.chainOption} args the tween animation start time
   * @returns {TweenBase} this instance
   */
  chain(args) {
    this._chain = [];
    this._chain = args.length ? args : this._chain.concat(args);
    return this;
  }
  /**
   * Stop tweening the chained tween instances.
   */
  stopChainedTweens() {
    if (this._chain && this._chain.length) this._chain.forEach((tw) => tw.stop());
  }
  /**
   * Update the tween on each tick.
   * @param {number} time the tick time
   * @returns {boolean} this instance
   */
  update(time) {
    const T = time !== void 0 ? time : KEC.Time();
    let elapsed;
    if (T < this._startTime && this.playing) {
      return true;
    }
    elapsed = (T - this._startTime) / this._duration;
    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
    const progress = this._easing(elapsed);
    Object.keys(this.valuesEnd).forEach((tweenProp) => {
      KEC[tweenProp](
        this.element,
        this.valuesStart[tweenProp],
        this.valuesEnd[tweenProp],
        progress
      );
    });
    if (this._onUpdate) {
      this._onUpdate.call(this);
    }
    if (elapsed === 1) {
      if (this._onComplete) {
        this._onComplete.call(this);
      }
      this.playing = false;
      this.close();
      if (this._chain !== void 0 && this._chain.length) {
        this._chain.map((tw) => tw.start());
      }
      return false;
    }
    return true;
  }
};
connect.tween = TweenBase;
var Tween = class extends TweenBase {
  /**
   * @param {KUTE.tweenParams} args (*target*, *startValues*, *endValues*, *options*)
   * @returns {Tween} the resulting Tween object
   */
  constructor(...args) {
    super(...args);
    this.valuesStart = {};
    this.valuesEnd = {};
    const [startObject, endObject, options] = args.slice(1);
    prepareObject.call(this, endObject, "end");
    if (this._resetStart) {
      this.valuesStart = startObject;
    } else {
      prepareObject.call(this, startObject, "start");
    }
    if (!this._resetStart) {
      Object.keys(crossCheck).forEach((component) => {
        Object.keys(crossCheck[component]).forEach((checkProp) => {
          crossCheck[component][checkProp].call(this, checkProp);
        });
      });
    }
    this.paused = false;
    this._pauseTime = null;
    this._repeat = options.repeat || defaultOptions$1.repeat;
    this._repeatDelay = options.repeatDelay || defaultOptions$1.repeatDelay;
    this._repeatOption = this._repeat;
    this.valuesRepeat = {};
    this._yoyo = options.yoyo || defaultOptions$1.yoyo;
    this._reversed = false;
    return this;
  }
  /**
   * Starts tweening, extended method
   * @param {number?} time the tween start time
   * @returns {Tween} this instance
   */
  start(time) {
    if (this._resetStart) {
      this.valuesStart = this._resetStart;
      getStartValues.call(this);
      Object.keys(crossCheck).forEach((component) => {
        Object.keys(crossCheck[component]).forEach((checkProp) => {
          crossCheck[component][checkProp].call(this, checkProp);
        });
      });
    }
    this.paused = false;
    if (this._yoyo) {
      Object.keys(this.valuesEnd).forEach((endProp) => {
        this.valuesRepeat[endProp] = this.valuesStart[endProp];
      });
    }
    super.start(time);
    return this;
  }
  /**
   * Stops tweening, extended method
   * @returns {Tween} this instance
   */
  stop() {
    super.stop();
    if (!this.paused && this.playing) {
      this.paused = false;
      this.stopChainedTweens();
    }
    return this;
  }
  /**
   * Trigger internal completion callbacks.
   */
  close() {
    super.close();
    if (this._repeatOption > 0) {
      this._repeat = this._repeatOption;
    }
    if (this._yoyo && this._reversed === true) {
      this.reverse();
      this._reversed = false;
    }
    return this;
  }
  /**
   * Resume tweening
   * @returns {Tween} this instance
   */
  resume() {
    if (this.paused && this.playing) {
      this.paused = false;
      if (this._onResume !== void 0) {
        this._onResume.call(this);
      }
      queueStart.call(this);
      this._startTime += KEC.Time() - this._pauseTime;
      add(this);
      if (!Tick) Ticker();
    }
    return this;
  }
  /**
   * Pause tweening
   * @returns {Tween} this instance
   */
  pause() {
    if (!this.paused && this.playing) {
      remove(this);
      this.paused = true;
      this._pauseTime = KEC.Time();
      if (this._onPause !== void 0) {
        this._onPause.call(this);
      }
    }
    return this;
  }
  /**
   * Reverses start values with end values
   */
  reverse() {
    Object.keys(this.valuesEnd).forEach((reverseProp) => {
      const tmp = this.valuesRepeat[reverseProp];
      this.valuesRepeat[reverseProp] = this.valuesEnd[reverseProp];
      this.valuesEnd[reverseProp] = tmp;
      this.valuesStart[reverseProp] = this.valuesRepeat[reverseProp];
    });
  }
  /**
   * Update the tween on each tick.
   * @param {number} time the tick time
   * @returns {boolean} this instance
   */
  update(time) {
    const T = time !== void 0 ? time : KEC.Time();
    let elapsed;
    if (T < this._startTime && this.playing) {
      return true;
    }
    elapsed = (T - this._startTime) / this._duration;
    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
    const progress = this._easing(elapsed);
    Object.keys(this.valuesEnd).forEach((tweenProp) => {
      KEC[tweenProp](
        this.element,
        this.valuesStart[tweenProp],
        this.valuesEnd[tweenProp],
        progress
      );
    });
    if (this._onUpdate) {
      this._onUpdate.call(this);
    }
    if (elapsed === 1) {
      if (this._repeat > 0) {
        if (Number.isFinite(this._repeat)) this._repeat -= 1;
        this._startTime = T;
        if (Number.isFinite(this._repeat) && this._yoyo && !this._reversed) {
          this._startTime += this._repeatDelay;
        }
        if (this._yoyo) {
          this._reversed = !this._reversed;
          this.reverse();
        }
        return true;
      }
      if (this._onComplete) {
        this._onComplete.call(this);
      }
      this.playing = false;
      this.close();
      if (this._chain !== void 0 && this._chain.length) {
        this._chain.forEach((tw) => tw.start());
      }
      return false;
    }
    return true;
  }
};
connect.tween = Tween;
var TweenCollection = class _TweenCollection {
  /**
   *
   * @param {Element[] | HTMLCollection | NodeList} els target elements
   * @param {KUTE.tweenProps} vS the start values
   * @param {KUTE.tweenProps} vE the end values
   * @param {KUTE.tweenOptions} Options tween options
   * @returns {TweenCollection} the Tween object collection
   */
  constructor(els, vS, vE, Options) {
    const TweenConstructor2 = connect.tween;
    this.tweens = [];
    const Ops = Options || {};
    Ops.delay = Ops.delay || defaultOptions$1.delay;
    const options = [];
    Array.from(els).forEach((el, i) => {
      options[i] = Ops || {};
      options[i].delay = i > 0 ? Ops.delay + (Ops.offset || defaultOptions$1.offset) : Ops.delay;
      if (el instanceof Element) {
        this.tweens.push(new TweenConstructor2(el, vS, vE, options[i]));
      } else {
        throw Error(`KUTE - ${el} is not instanceof Element`);
      }
    });
    this.length = this.tweens.length;
    return this;
  }
  /**
   * Starts tweening, all targets
   * @param {number?} time the tween start time
   * @returns {TweenCollection} this instance
   */
  start(time) {
    const T = time === void 0 ? KEC.Time() : time;
    this.tweens.map((tween) => tween.start(T));
    return this;
  }
  /**
   * Stops tweening, all targets and their chains
   * @returns {TweenCollection} this instance
   */
  stop() {
    this.tweens.map((tween) => tween.stop());
    return this;
  }
  /**
   * Pause tweening, all targets
   * @returns {TweenCollection} this instance
   */
  pause() {
    this.tweens.map((tween) => tween.pause());
    return this;
  }
  /**
   * Resume tweening, all targets
   * @returns {TweenCollection} this instance
   */
  resume() {
    this.tweens.map((tween) => tween.resume());
    return this;
  }
  /**
   * Schedule another tween or collection to start after
   * this one is complete.
   * @param {number?} args the tween start time
   * @returns {TweenCollection} this instance
   */
  chain(args) {
    const lastTween = this.tweens[this.length - 1];
    if (args instanceof _TweenCollection) {
      lastTween.chain(args.tweens);
    } else if (args instanceof connect.tween) {
      lastTween.chain(args);
    } else {
      throw new TypeError("KUTE.js - invalid chain value");
    }
    return this;
  }
  /**
   * Check if any tween instance is playing
   * @param {number?} time the tween start time
   * @returns {TweenCollection} this instance
   */
  playing() {
    return this.tweens.some((tw) => tw.playing);
  }
  /**
   * Remove all tweens in the collection
   */
  removeTweens() {
    this.tweens = [];
  }
  /**
   * Returns the maximum animation duration
   * @returns {number} this instance
   */
  getMaxDuration() {
    const durations = [];
    this.tweens.forEach((tw) => {
      durations.push(tw._duration + tw._delay + tw._repeat * tw._repeatDelay);
    });
    return Math.max(durations);
  }
};
var { tween: TweenConstructor$1 } = connect;
function to(element, endObject, optionsObj) {
  const options = optionsObj || {};
  options.resetStart = endObject;
  return new TweenConstructor$1(selector(element), endObject, endObject, options);
}
var { tween: TweenConstructor } = connect;
function fromTo(element, startObject, endObject, optionsObj) {
  const options = optionsObj || {};
  return new TweenConstructor(selector(element), startObject, endObject, options);
}
function allTo(elements, endObject, optionsObj) {
  const options = optionsObj || {};
  options.resetStart = endObject;
  return new TweenCollection(selector(elements, true), endObject, endObject, options);
}
function allFromTo(elements, startObject, endObject, optionsObj) {
  const options = optionsObj || {};
  return new TweenCollection(selector(elements, true), startObject, endObject, options);
}
var Animation = class {
  /**
   * @constructor
   * @param {KUTE.fullComponent} Component
   */
  constructor(Component) {
    try {
      if (Component.component in supportedProperties) {
        throw Error(`KUTE - ${Component.component} already registered`);
      } else if (Component.property in defaultValues) {
        throw Error(`KUTE - ${Component.property} already registered`);
      }
    } catch (e) {
      throw Error(e);
    }
    const propertyInfo = this;
    const ComponentName2 = Component.component;
    const Functions = {
      prepareProperty,
      prepareStart,
      onStart,
      onComplete,
      crossCheck
    };
    const Category = Component.category;
    const Property = Component.property;
    const Length = Component.properties && Component.properties.length || Component.subProperties && Component.subProperties.length;
    supportedProperties[ComponentName2] = Component.properties || Component.subProperties || Component.property;
    if ("defaultValue" in Component) {
      defaultValues[Property] = Component.defaultValue;
      propertyInfo.supports = `${Property} property`;
    } else if (Component.defaultValues) {
      Object.keys(Component.defaultValues).forEach((dv) => {
        defaultValues[dv] = Component.defaultValues[dv];
      });
      propertyInfo.supports = `${Length || Property} ${Property || Category} properties`;
    }
    if (Component.defaultOptions) {
      Object.assign(defaultOptions$1, Component.defaultOptions);
    }
    if (Component.functions) {
      Object.keys(Functions).forEach((fn) => {
        if (fn in Component.functions) {
          if (typeof Component.functions[fn] === "function") {
            if (!Functions[fn][ComponentName2]) Functions[fn][ComponentName2] = {};
            if (!Functions[fn][ComponentName2][Category || Property]) {
              Functions[fn][ComponentName2][Category || Property] = Component.functions[fn];
            }
          } else {
            Object.keys(Component.functions[fn]).forEach((ofn) => {
              if (!Functions[fn][ComponentName2]) Functions[fn][ComponentName2] = {};
              if (!Functions[fn][ComponentName2][ofn]) {
                Functions[fn][ComponentName2][ofn] = Component.functions[fn][ofn];
              }
            });
          }
        }
      });
    }
    if (Component.Interpolate) {
      Object.keys(Component.Interpolate).forEach((fni) => {
        const compIntObj = Component.Interpolate[fni];
        if (typeof compIntObj === "function" && !interpolate[fni]) {
          interpolate[fni] = compIntObj;
        } else {
          Object.keys(compIntObj).forEach((sfn) => {
            if (typeof compIntObj[sfn] === "function" && !interpolate[fni]) {
              interpolate[fni] = compIntObj[sfn];
            }
          });
        }
      });
      linkProperty[ComponentName2] = Component.Interpolate;
    }
    if (Component.Util) {
      Object.keys(Component.Util).forEach((fnu) => {
        if (!Util[fnu]) Util[fnu] = Component.Util[fnu];
      });
    }
    return propertyInfo;
  }
};
var trueDimension = (dimValue, isAngle) => {
  const intValue = parseInt(dimValue, 10) || 0;
  const mUnits = ["px", "%", "deg", "rad", "em", "rem", "vh", "vw"];
  let theUnit;
  for (let mIndex = 0; mIndex < mUnits.length; mIndex += 1) {
    if (typeof dimValue === "string" && dimValue.includes(mUnits[mIndex])) {
      theUnit = mUnits[mIndex];
      break;
    }
  }
  if (theUnit === void 0) {
    theUnit = isAngle ? "deg" : "px";
  }
  return { v: intValue, u: theUnit };
};
function numbers(a, b, v) {
  const A = +a;
  const B = b - a;
  return A + B * v;
}
function boxModelOnStart(tweenProp) {
  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {
    KEC[tweenProp] = (elem, a, b, v) => {
      elem.style[tweenProp] = `${v > 0.99 || v < 0.01 ? (numbers(a, b, v) * 10 >> 0) / 10 : numbers(a, b, v) >> 0}px`;
    };
  }
}
function getBoxModel(tweenProp) {
  return getStyleForProperty(this.element, tweenProp) || defaultValues[tweenProp];
}
function prepareBoxModel(tweenProp, value) {
  const boxValue = trueDimension(value);
  const offsetProp = tweenProp === "height" ? "offsetHeight" : "offsetWidth";
  return boxValue.u === "%" ? boxValue.v * this.element[offsetProp] / 100 : boxValue.v;
}
var essentialBoxProps = ["top", "left", "width", "height"];
var essentialBoxPropsValues = {
  top: 0,
  left: 0,
  width: 0,
  height: 0
};
var essentialBoxOnStart = {};
essentialBoxProps.forEach((x) => {
  essentialBoxOnStart[x] = boxModelOnStart;
});
var essentialBoxModelFunctions = {
  prepareStart: getBoxModel,
  prepareProperty: prepareBoxModel,
  onStart: essentialBoxOnStart
};
var BoxModelEssential = {
  component: "essentialBoxModel",
  category: "boxModel",
  properties: essentialBoxProps,
  defaultValues: essentialBoxPropsValues,
  Interpolate: { numbers },
  functions: essentialBoxModelFunctions,
  Util: { trueDimension }
};
var hexToRGB = (hex) => {
  const hexShorthand = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  const HEX = hex.replace(hexShorthand, (_, r, g, b) => r + r + g + g + b + b);
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(HEX);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
};
var trueColor = (colorString) => {
  let result;
  if (/rgb|rgba/.test(colorString)) {
    const vrgb = colorString.replace(/\s|\)/, "").split("(")[1].split(",");
    const colorAlpha = vrgb[3] ? vrgb[3] : null;
    if (!colorAlpha) {
      result = { r: parseInt(vrgb[0], 10), g: parseInt(vrgb[1], 10), b: parseInt(vrgb[2], 10) };
    } else {
      result = {
        r: parseInt(vrgb[0], 10),
        g: parseInt(vrgb[1], 10),
        b: parseInt(vrgb[2], 10),
        a: parseFloat(colorAlpha)
      };
    }
  }
  if (/^#/.test(colorString)) {
    const fromHex = hexToRGB(colorString);
    result = { r: fromHex.r, g: fromHex.g, b: fromHex.b };
  }
  if (/transparent|none|initial|inherit/.test(colorString)) {
    result = {
      r: 0,
      g: 0,
      b: 0,
      a: 0
    };
  }
  if (!/^#|^rgb/.test(colorString)) {
    const siteHead = document.getElementsByTagName("head")[0];
    siteHead.style.color = colorString;
    let webColor = getComputedStyle(siteHead, null).color;
    webColor = /rgb/.test(webColor) ? webColor.replace(/[^\d,]/g, "").split(",") : [0, 0, 0];
    siteHead.style.color = "";
    result = {
      r: parseInt(webColor[0], 10),
      g: parseInt(webColor[1], 10),
      b: parseInt(webColor[2], 10)
    };
  }
  return result;
};
function colors(a, b, v) {
  const _c = {};
  const ep = ")";
  const cm = ",";
  const rgb = "rgb(";
  const rgba = "rgba(";
  Object.keys(b).forEach((c) => {
    if (c !== "a") {
      _c[c] = numbers(a[c], b[c], v) >> 0 || 0;
    } else if (a[c] && b[c]) {
      _c[c] = (numbers(a[c], b[c], v) * 100 >> 0) / 100;
    }
  });
  return !_c.a ? rgb + _c.r + cm + _c.g + cm + _c.b + ep : rgba + _c.r + cm + _c.g + cm + _c.b + cm + _c.a + ep;
}
function onStartColors(tweenProp) {
  if (this.valuesEnd[tweenProp] && !KEC[tweenProp]) {
    KEC[tweenProp] = (elem, a, b, v) => {
      elem.style[tweenProp] = colors(a, b, v);
    };
  }
}
var supportedColors = [
  "color",
  "backgroundColor",
  "outlineColor",
  "borderColor",
  "borderTopColor",
  "borderRightColor",
  "borderBottomColor",
  "borderLeftColor"
];
var defaultColors = {};
supportedColors.forEach((tweenProp) => {
  defaultColors[tweenProp] = "#000";
});
var colorsOnStart = {};
supportedColors.forEach((x) => {
  colorsOnStart[x] = onStartColors;
});
function getColor(prop) {
  return getStyleForProperty(this.element, prop) || defaultValues[prop];
}
function prepareColor(_, value) {
  return trueColor(value);
}
var colorFunctions = {
  prepareStart: getColor,
  prepareProperty: prepareColor,
  onStart: colorsOnStart
};
var colorProperties = {
  component: "colorProperties",
  category: "colors",
  properties: supportedColors,
  defaultValues: defaultColors,
  Interpolate: { numbers, colors },
  functions: colorFunctions,
  Util: { trueColor }
};
var attributes = {};
var onStartAttr = {
  /**
   * onStartAttr.attr
   *
   * Sets the sub-property update function.
   * @param {string} tweenProp the property name
   */
  attr(tweenProp) {
    if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {
      KEC[tweenProp] = (elem, vS, vE, v) => {
        Object.keys(vE).forEach((oneAttr) => {
          KEC.attributes[oneAttr](elem, oneAttr, vS[oneAttr], vE[oneAttr], v);
        });
      };
    }
  },
  /**
   * onStartAttr.attributes
   *
   * Sets the update function for the property.
   * @param {string} tweenProp the property name
   */
  attributes(tweenProp) {
    if (!KEC[tweenProp] && this.valuesEnd.attr) {
      KEC[tweenProp] = attributes;
    }
  }
};
var ComponentName = "htmlAttributes";
var svgColors = ["fill", "stroke", "stop-color"];
function replaceUppercase(a) {
  return a.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function getAttr(_, value) {
  const attrStartValues = {};
  Object.keys(value).forEach((attr) => {
    const attribute = replaceUppercase(attr).replace(/_+[a-z]+/, "");
    const currentValue = this.element.getAttribute(attribute);
    attrStartValues[attribute] = svgColors.includes(attribute) ? currentValue || "rgba(0,0,0,0)" : currentValue || (/opacity/i.test(attr) ? 1 : 0);
  });
  return attrStartValues;
}
function prepareAttr(tweenProp, attrObj) {
  const attributesObject = {};
  Object.keys(attrObj).forEach((p) => {
    const prop = replaceUppercase(p);
    const regex = /(%|[a-z]+)$/;
    const currentValue = this.element.getAttribute(prop.replace(/_+[a-z]+/, ""));
    if (!svgColors.includes(prop)) {
      if (currentValue !== null && regex.test(currentValue)) {
        const unit = trueDimension(currentValue).u || trueDimension(attrObj[p]).u;
        const suffix = /%/.test(unit) ? "_percent" : `_${unit}`;
        onStart[ComponentName][prop + suffix] = (tp) => {
          if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {
            attributes[tp] = (elem, oneAttr, a, b, v) => {
              const _p = oneAttr.replace(suffix, "");
              elem.setAttribute(_p, (numbers(a.v, b.v, v) * 1e3 >> 0) / 1e3 + b.u);
            };
          }
        };
        attributesObject[prop + suffix] = trueDimension(attrObj[p]);
      } else if (!regex.test(attrObj[p]) || currentValue === null || currentValue && !regex.test(currentValue)) {
        onStart[ComponentName][prop] = (tp) => {
          if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {
            attributes[tp] = (elem, oneAttr, a, b, v) => {
              elem.setAttribute(oneAttr, (numbers(a, b, v) * 1e3 >> 0) / 1e3);
            };
          }
        };
        attributesObject[prop] = parseFloat(attrObj[p]);
      }
    } else {
      onStart[ComponentName][prop] = (tp) => {
        if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {
          attributes[tp] = (elem, oneAttr, a, b, v) => {
            elem.setAttribute(oneAttr, colors(a, b, v));
          };
        }
      };
      attributesObject[prop] = trueColor(attrObj[p]) || defaultValues.htmlAttributes[p];
    }
  });
  return attributesObject;
}
var attrFunctions = {
  prepareStart: getAttr,
  prepareProperty: prepareAttr,
  onStart: onStartAttr
};
var htmlAttributes = {
  component: ComponentName,
  property: "attr",
  // the Animation class will need some values to validate this Object attribute
  subProperties: ["fill", "stroke", "stop-color", "fill-opacity", "stroke-opacity"],
  defaultValue: {
    fill: "rgb(0,0,0)",
    stroke: "rgb(0,0,0)",
    "stop-color": "rgb(0,0,0)",
    opacity: 1,
    "stroke-opacity": 1,
    "fill-opacity": 1
    // same here
  },
  Interpolate: { numbers, colors },
  functions: attrFunctions,
  // export to global for faster execution
  Util: { replaceUppercase, trueColor, trueDimension }
};
function onStartOpacity(tweenProp) {
  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {
    KEC[tweenProp] = (elem, a, b, v) => {
      elem.style[tweenProp] = (numbers(a, b, v) * 1e3 >> 0) / 1e3;
    };
  }
}
function getOpacity(tweenProp) {
  return getStyleForProperty(this.element, tweenProp);
}
function prepareOpacity(_, value) {
  return parseFloat(value);
}
var opacityFunctions = {
  prepareStart: getOpacity,
  prepareProperty: prepareOpacity,
  onStart: onStartOpacity
};
var OpacityProperty = {
  component: "opacityProperty",
  property: "opacity",
  defaultValue: 1,
  Interpolate: { numbers },
  functions: opacityFunctions
};
var lowerCaseAlpha = String("abcdefghijklmnopqrstuvwxyz").split("");
var upperCaseAlpha = String("abcdefghijklmnopqrstuvwxyz").toUpperCase().split("");
var nonAlpha = String("~!@#$%^&*()_+{}[];'<>,./?=-").split("");
var numeric = String("0123456789").split("");
var alphaNumeric = lowerCaseAlpha.concat(upperCaseAlpha, numeric);
var allTypes = alphaNumeric.concat(nonAlpha);
var charSet = {
  alpha: lowerCaseAlpha,
  // lowercase
  upper: upperCaseAlpha,
  // uppercase
  symbols: nonAlpha,
  // symbols
  numeric,
  alphanumeric: alphaNumeric,
  all: allTypes
};
var onStartWrite = {
  /**
   * onStartWrite.text
   *
   * Sets the property update function.
   * @param {string} tweenProp the property name
   */
  text(tweenProp) {
    if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {
      const chars = this._textChars;
      let charsets = charSet[defaultOptions$1.textChars];
      if (chars in charSet) {
        charsets = charSet[chars];
      } else if (chars && chars.length) {
        charsets = chars;
      }
      KEC[tweenProp] = (elem, a, b, v) => {
        let initialText = "";
        let endText = "";
        const finalText = b === "" ? " " : b;
        const firstLetterA = a.substring(0);
        const firstLetterB = b.substring(0);
        const pointer = charsets[Math.random() * charsets.length >> 0];
        if (a === " ") {
          endText = firstLetterB.substring(Math.min(v * firstLetterB.length, firstLetterB.length) >> 0, 0);
          elem.innerHTML = v < 1 ? endText + pointer : finalText;
        } else if (b === " ") {
          initialText = firstLetterA.substring(0, Math.min((1 - v) * firstLetterA.length, firstLetterA.length) >> 0);
          elem.innerHTML = v < 1 ? initialText + pointer : finalText;
        } else {
          initialText = firstLetterA.substring(
            firstLetterA.length,
            Math.min(v * firstLetterA.length, firstLetterA.length) >> 0
          );
          endText = firstLetterB.substring(0, Math.min(v * firstLetterB.length, firstLetterB.length) >> 0);
          elem.innerHTML = v < 1 ? endText + pointer + initialText : finalText;
        }
      };
    }
  },
  /**
   * onStartWrite.number
   *
   * Sets the property update function.
   * @param {string} tweenProp the property name
   */
  number(tweenProp) {
    if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {
      KEC[tweenProp] = (elem, a, b, v) => {
        elem.innerHTML = numbers(a, b, v) >> 0;
      };
    }
  }
};
function wrapContentsSpan(el, classNAME) {
  let textWriteWrapper;
  let newElem;
  if (typeof el === "string") {
    newElem = document.createElement("SPAN");
    newElem.innerHTML = el;
    newElem.className = classNAME;
    return newElem;
  }
  if (!el.children.length || el.children.length && el.children[0].className !== classNAME) {
    const elementInnerHTML = el.innerHTML;
    textWriteWrapper = document.createElement("SPAN");
    textWriteWrapper.className = classNAME;
    textWriteWrapper.innerHTML = elementInnerHTML;
    el.appendChild(textWriteWrapper);
    el.innerHTML = textWriteWrapper.outerHTML;
  } else if (el.children.length && el.children[0].className === classNAME) {
    [textWriteWrapper] = el.children;
  }
  return textWriteWrapper;
}
function getTextPartsArray(el, classNAME) {
  let elementsArray = [];
  const len = el.children.length;
  if (len) {
    const textParts = [];
    let remainingMarkup = el.innerHTML;
    let wrapperParts;
    for (let i = 0, currentChild, childOuter, unTaggedContent; i < len; i += 1) {
      currentChild = el.children[i];
      childOuter = currentChild.outerHTML;
      wrapperParts = remainingMarkup.split(childOuter);
      if (wrapperParts[0] !== "") {
        unTaggedContent = wrapContentsSpan(wrapperParts[0], classNAME);
        textParts.push(unTaggedContent);
        remainingMarkup = remainingMarkup.replace(wrapperParts[0], "");
      } else if (wrapperParts[1] !== "") {
        unTaggedContent = wrapContentsSpan(wrapperParts[1].split("<")[0], classNAME);
        textParts.push(unTaggedContent);
        remainingMarkup = remainingMarkup.replace(wrapperParts[0].split("<")[0], "");
      }
      if (!currentChild.classList.contains(classNAME)) currentChild.classList.add(classNAME);
      textParts.push(currentChild);
      remainingMarkup = remainingMarkup.replace(childOuter, "");
    }
    if (remainingMarkup !== "") {
      const unTaggedRemaining = wrapContentsSpan(remainingMarkup, classNAME);
      textParts.push(unTaggedRemaining);
    }
    elementsArray = elementsArray.concat(textParts);
  } else {
    elementsArray = elementsArray.concat([wrapContentsSpan(el, classNAME)]);
  }
  return elementsArray;
}
function setSegments(target, newText) {
  const oldTargetSegs = getTextPartsArray(target, "text-part");
  const newTargetSegs = getTextPartsArray(wrapContentsSpan(newText), "text-part");
  target.innerHTML = "";
  target.innerHTML += oldTargetSegs.map((s) => {
    s.className += " oldText";
    return s.outerHTML;
  }).join("");
  target.innerHTML += newTargetSegs.map((s) => {
    s.className += " newText";
    return s.outerHTML.replace(s.innerHTML, "");
  }).join("");
  return [oldTargetSegs, newTargetSegs];
}
function createTextTweens(target, newText, ops) {
  if (target.playing) return false;
  const options = ops || {};
  options.duration = 1e3;
  if (ops.duration === "auto") {
    options.duration = "auto";
  } else if (Number.isFinite(ops.duration * 1)) {
    options.duration = ops.duration * 1;
  }
  const TweenContructor = connect.tween;
  const segs = setSegments(target, newText);
  const oldTargetSegs = segs[0];
  const newTargetSegs = segs[1];
  const oldTargets = [].slice.call(target.getElementsByClassName("oldText")).reverse();
  const newTargets = [].slice.call(target.getElementsByClassName("newText"));
  let textTween = [];
  let totalDelay = 0;
  textTween = textTween.concat(oldTargets.map((el, i) => {
    options.duration = options.duration === "auto" ? oldTargetSegs[i].innerHTML.length * 75 : options.duration;
    options.delay = totalDelay;
    options.onComplete = null;
    totalDelay += options.duration;
    return new TweenContructor(el, { text: el.innerHTML }, { text: "" }, options);
  }));
  textTween = textTween.concat(newTargets.map((el, i) => {
    function onComplete2() {
      target.innerHTML = newText;
      target.playing = false;
    }
    options.duration = options.duration === "auto" ? newTargetSegs[i].innerHTML.length * 75 : options.duration;
    options.delay = totalDelay;
    options.onComplete = i === newTargetSegs.length - 1 ? onComplete2 : null;
    totalDelay += options.duration;
    return new TweenContructor(el, { text: "" }, { text: newTargetSegs[i].innerHTML }, options);
  }));
  textTween.start = function startTweens() {
    if (!target.playing) {
      textTween.forEach((tw) => tw.start());
      target.playing = true;
    }
  };
  return textTween;
}
function getWrite() {
  return this.element.innerHTML;
}
function prepareText(tweenProp, value) {
  if (tweenProp === "number") {
    return parseFloat(value);
  }
  return value === "" ? " " : value;
}
var textWriteFunctions = {
  prepareStart: getWrite,
  prepareProperty: prepareText,
  onStart: onStartWrite
};
var TextWrite = {
  component: "textWriteProperties",
  category: "textWrite",
  properties: ["text", "number"],
  defaultValues: { text: " ", number: "0" },
  defaultOptions: { textChars: "alpha" },
  Interpolate: { numbers },
  functions: textWriteFunctions,
  // export to global for faster execution
  Util: { charSet, createTextTweens }
};
function perspective(a, b, u, v) {
  return `perspective(${((a + (b - a) * v) * 1e3 >> 0) / 1e3}${u})`;
}
function translate3d(a, b, u, v) {
  const translateArray = [];
  for (let ax = 0; ax < 3; ax += 1) {
    translateArray[ax] = (a[ax] || b[ax] ? ((a[ax] + (b[ax] - a[ax]) * v) * 1e3 >> 0) / 1e3 : 0) + u;
  }
  return `translate3d(${translateArray.join(",")})`;
}
function rotate3d(a, b, u, v) {
  let rotateStr = "";
  rotateStr += a[0] || b[0] ? `rotateX(${((a[0] + (b[0] - a[0]) * v) * 1e3 >> 0) / 1e3}${u})` : "";
  rotateStr += a[1] || b[1] ? `rotateY(${((a[1] + (b[1] - a[1]) * v) * 1e3 >> 0) / 1e3}${u})` : "";
  rotateStr += a[2] || b[2] ? `rotateZ(${((a[2] + (b[2] - a[2]) * v) * 1e3 >> 0) / 1e3}${u})` : "";
  return rotateStr;
}
function translate(a, b, u, v) {
  const translateArray = [];
  translateArray[0] = (a[0] === b[0] ? b[0] : ((a[0] + (b[0] - a[0]) * v) * 1e3 >> 0) / 1e3) + u;
  translateArray[1] = a[1] || b[1] ? (a[1] === b[1] ? b[1] : ((a[1] + (b[1] - a[1]) * v) * 1e3 >> 0) / 1e3) + u : "0";
  return `translate(${translateArray.join(",")})`;
}
function rotate(a, b, u, v) {
  return `rotate(${((a + (b - a) * v) * 1e3 >> 0) / 1e3}${u})`;
}
function scale(a, b, v) {
  return `scale(${((a + (b - a) * v) * 1e3 >> 0) / 1e3})`;
}
function skew(a, b, u, v) {
  const skewArray = [];
  skewArray[0] = (a[0] === b[0] ? b[0] : ((a[0] + (b[0] - a[0]) * v) * 1e3 >> 0) / 1e3) + u;
  skewArray[1] = a[1] || b[1] ? (a[1] === b[1] ? b[1] : ((a[1] + (b[1] - a[1]) * v) * 1e3 >> 0) / 1e3) + u : "0";
  return `skew(${skewArray.join(",")})`;
}
function onStartTransform(tweenProp) {
  if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {
    KEC[tweenProp] = (elem, a, b, v) => {
      elem.style[tweenProp] = (a.perspective || b.perspective ? perspective(a.perspective, b.perspective, "px", v) : "") + (a.translate3d ? translate3d(a.translate3d, b.translate3d, "px", v) : "") + (a.rotate3d ? rotate3d(a.rotate3d, b.rotate3d, "deg", v) : "") + (a.skew ? skew(a.skew, b.skew, "deg", v) : "") + (a.scale || b.scale ? scale(a.scale, b.scale, v) : "");
    };
  }
}
function getTransform(tweenProp) {
  const currentStyle = getInlineStyle(this.element);
  return currentStyle[tweenProp] ? currentStyle[tweenProp] : defaultValues[tweenProp];
}
function prepareTransform(_, obj) {
  const prepAxis = ["X", "Y", "Z"];
  const transformObject = {};
  const translateArray = [];
  const rotateArray = [];
  const skewArray = [];
  const arrayFunctions = ["translate3d", "translate", "rotate3d", "skew"];
  Object.keys(obj).forEach((x) => {
    const pv = typeof obj[x] === "object" && obj[x].length ? obj[x].map((v) => parseInt(v, 10)) : parseInt(obj[x], 10);
    if (arrayFunctions.includes(x)) {
      const propId = x === "translate" || x === "rotate" ? `${x}3d` : x;
      if (x === "skew") {
        transformObject[propId] = pv.length ? [pv[0] || 0, pv[1] || 0] : [pv || 0, 0];
      } else if (x === "translate") {
        transformObject[propId] = pv.length ? [pv[0] || 0, pv[1] || 0, pv[2] || 0] : [pv || 0, 0, 0];
      } else {
        transformObject[propId] = [pv[0] || 0, pv[1] || 0, pv[2] || 0];
      }
    } else if (/[XYZ]/.test(x)) {
      const fn = x.replace(/[XYZ]/, "");
      const fnId = fn === "skew" ? fn : `${fn}3d`;
      const fnLen = fn === "skew" ? 2 : 3;
      let fnArray = [];
      if (fn === "translate") {
        fnArray = translateArray;
      } else if (fn === "rotate") {
        fnArray = rotateArray;
      } else if (fn === "skew") {
        fnArray = skewArray;
      }
      for (let fnIndex = 0; fnIndex < fnLen; fnIndex += 1) {
        const fnAxis = prepAxis[fnIndex];
        fnArray[fnIndex] = `${fn}${fnAxis}` in obj ? parseInt(obj[`${fn}${fnAxis}`], 10) : 0;
      }
      transformObject[fnId] = fnArray;
    } else if (x === "rotate") {
      transformObject.rotate3d = [0, 0, pv];
    } else {
      transformObject[x] = x === "scale" ? parseFloat(obj[x]) : pv;
    }
  });
  return transformObject;
}
function crossCheckTransform(tweenProp) {
  if (this.valuesEnd[tweenProp]) {
    if (this.valuesEnd[tweenProp]) {
      if (this.valuesEnd[tweenProp].perspective && !this.valuesStart[tweenProp].perspective) {
        this.valuesStart[tweenProp].perspective = this.valuesEnd[tweenProp].perspective;
      }
    }
  }
}
var transformFunctions = {
  prepareStart: getTransform,
  prepareProperty: prepareTransform,
  onStart: onStartTransform,
  crossCheck: crossCheckTransform
};
var supportedTransformProperties = [
  "perspective",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "translate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "rotate",
  "skewX",
  "skewY",
  "skew",
  "scale"
];
var defaultTransformValues = {
  perspective: 400,
  translate3d: [0, 0, 0],
  translateX: 0,
  translateY: 0,
  translateZ: 0,
  translate: [0, 0],
  rotate3d: [0, 0, 0],
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  rotate: 0,
  skewX: 0,
  skewY: 0,
  skew: [0, 0],
  scale: 1
};
var TransformFunctions = {
  component: "transformFunctions",
  property: "transform",
  subProperties: supportedTransformProperties,
  defaultValues: defaultTransformValues,
  functions: transformFunctions,
  Interpolate: {
    perspective,
    translate3d,
    rotate3d,
    translate,
    rotate,
    scale,
    skew
  }
};
function onStartDraw(tweenProp) {
  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {
    KEC[tweenProp] = (elem, a, b, v) => {
      const pathLength = (a.l * 100 >> 0) / 100;
      const start = (numbers(a.s, b.s, v) * 100 >> 0) / 100;
      const end = (numbers(a.e, b.e, v) * 100 >> 0) / 100;
      const offset = 0 - start;
      const dashOne = end + offset;
      elem.style.strokeDashoffset = `${offset}px`;
      elem.style.strokeDasharray = `${((dashOne < 1 ? 0 : dashOne) * 100 >> 0) / 100}px, ${pathLength}px`;
    };
  }
}
function percent(v, l) {
  return parseFloat(v) / 100 * l;
}
function getRectLength(el) {
  const w = el.getAttribute("width");
  const h = el.getAttribute("height");
  return w * 2 + h * 2;
}
function getPolyLength(el) {
  const points = el.getAttribute("points").split(" ");
  let len = 0;
  if (points.length > 1) {
    const coord = (p) => {
      const c = p.split(",");
      if (c.length !== 2) {
        return 0;
      }
      if (Number.isNaN(c[0] * 1) || Number.isNaN(c[1] * 1)) {
        return 0;
      }
      return [parseFloat(c[0]), parseFloat(c[1])];
    };
    const dist = (c1, c2) => {
      if (c1 !== void 0 && c2 !== void 0) {
        return Math.sqrt((c2[0] - c1[0]) ** 2 + (c2[1] - c1[1]) ** 2);
      }
      return 0;
    };
    if (points.length > 2) {
      for (let i = 0; i < points.length - 1; i += 1) {
        len += dist(coord(points[i]), coord(points[i + 1]));
      }
    }
    len += el.tagName === "polygon" ? dist(coord(points[0]), coord(points[points.length - 1])) : 0;
  }
  return len;
}
function getLineLength(el) {
  const x1 = el.getAttribute("x1");
  const x2 = el.getAttribute("x2");
  const y1 = el.getAttribute("y1");
  const y2 = el.getAttribute("y2");
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}
function getCircleLength(el) {
  const r = el.getAttribute("r");
  return 2 * Math.PI * r;
}
function getEllipseLength(el) {
  const rx = el.getAttribute("rx");
  const ry = el.getAttribute("ry");
  const len = 2 * rx;
  const wid = 2 * ry;
  return Math.sqrt(0.5 * (len * len + wid * wid)) * (Math.PI * 2) / 2;
}
function getTotalLength$1(el) {
  if (el.tagName === "rect") {
    return getRectLength(el);
  }
  if (el.tagName === "circle") {
    return getCircleLength(el);
  }
  if (el.tagName === "ellipse") {
    return getEllipseLength(el);
  }
  if (["polygon", "polyline"].includes(el.tagName)) {
    return getPolyLength(el);
  }
  if (el.tagName === "line") {
    return getLineLength(el);
  }
  return 0;
}
function getDraw(element, value) {
  const length = /path|glyph/.test(element.tagName) ? element.getTotalLength() : getTotalLength$1(element);
  let start;
  let end;
  let dasharray;
  let offset;
  if (value instanceof Object && Object.keys(value).every((v) => ["s", "e", "l"].includes(v))) {
    return value;
  }
  if (typeof value === "string") {
    const v = value.split(/,|\s/);
    start = /%/.test(v[0]) ? percent(v[0].trim(), length) : parseFloat(v[0]);
    end = /%/.test(v[1]) ? percent(v[1].trim(), length) : parseFloat(v[1]);
  } else if (typeof value === "undefined") {
    offset = parseFloat(getStyleForProperty(element, "stroke-dashoffset"));
    dasharray = getStyleForProperty(element, "stroke-dasharray").split(",");
    start = 0 - offset;
    end = parseFloat(dasharray[0]) + start || length;
  }
  return { s: start, e: end, l: length };
}
function resetDraw(elem) {
  elem.style.strokeDashoffset = "";
  elem.style.strokeDasharray = "";
}
function getDrawValue() {
  return getDraw(this.element);
}
function prepareDraw(_, value) {
  return getDraw(this.element, value);
}
var svgDrawFunctions = {
  prepareStart: getDrawValue,
  prepareProperty: prepareDraw,
  onStart: onStartDraw
};
var SvgDrawProperty = {
  component: "svgDraw",
  property: "draw",
  defaultValue: "0% 0%",
  Interpolate: { numbers },
  functions: svgDrawFunctions,
  // Export to global for faster execution
  Util: {
    getRectLength,
    getPolyLength,
    getLineLength,
    getCircleLength,
    getEllipseLength,
    getTotalLength: getTotalLength$1,
    resetDraw,
    getDraw,
    percent
  }
};
function fixArc(path, allPathCommands, i) {
  if (path[i].length > 7) {
    path[i].shift();
    const segment = path[i];
    let ni = i;
    while (segment.length) {
      allPathCommands[i] = "A";
      path.splice(ni += 1, 0, ["C", ...segment.splice(0, 6)]);
    }
    path.splice(i, 1);
  }
}
var paramsCount = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  r: 4,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};
function isPathArray(path) {
  return Array.isArray(path) && path.every((seg) => {
    const lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}
function isAbsoluteArray(path) {
  return isPathArray(path) && path.every(([x]) => x === x.toUpperCase());
}
function isNormalizedArray(path) {
  return isAbsoluteArray(path) && path.every(([pc]) => "ACLMQZ".includes(pc));
}
function isCurveArray(path) {
  return isNormalizedArray(path) && path.every(([pc]) => "MC".includes(pc));
}
function clonePath(path) {
  return path.map((x) => Array.isArray(x) ? [...x] : x);
}
function finalizeSegment(path) {
  let pathCommand = path.pathValue[path.segmentStart];
  let LK = pathCommand.toLowerCase();
  const { data } = path;
  while (data.length >= paramsCount[LK]) {
    if (LK === "m" && data.length > 2) {
      path.segments.push([pathCommand, ...data.splice(0, 2)]);
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path.segments.push([pathCommand, ...data.splice(0, paramsCount[LK])]);
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}
var error = "SVGPathCommander error";
function scanFlag(path) {
  const { index, pathValue } = path;
  const code = pathValue.charCodeAt(index);
  if (code === 48) {
    path.param = 0;
    path.index += 1;
    return;
  }
  if (code === 49) {
    path.param = 1;
    path.index += 1;
    return;
  }
  path.err = `${error}: invalid Arc flag "${pathValue[index]}", expecting 0 or 1 at index ${index}`;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
var invalidPathValue = "Invalid path value";
function scanParam(path) {
  const { max, pathValue, index: start } = path;
  let index = start;
  let zeroFirst = false;
  let hasCeiling = false;
  let hasDecimal = false;
  let hasDot = false;
  let ch;
  if (index >= max) {
    path.err = `${error}: ${invalidPathValue} at index ${index}, "pathValue" is missing param`;
    return;
  }
  ch = pathValue.charCodeAt(index);
  if (ch === 43 || ch === 45) {
    index += 1;
    ch = pathValue.charCodeAt(index);
  }
  if (!isDigit(ch) && ch !== 46) {
    path.err = `${error}: ${invalidPathValue} at index ${index}, "${pathValue[index]}" is not a number`;
    return;
  }
  if (ch !== 46) {
    zeroFirst = ch === 48;
    index += 1;
    ch = pathValue.charCodeAt(index);
    if (zeroFirst && index < max) {
      if (ch && isDigit(ch)) {
        path.err = `${error}: ${invalidPathValue} at index ${start}, "${pathValue[start]}" illegal number`;
        return;
      }
    }
    while (index < max && isDigit(pathValue.charCodeAt(index))) {
      index += 1;
      hasCeiling = true;
    }
    ch = pathValue.charCodeAt(index);
  }
  if (ch === 46) {
    hasDot = true;
    index += 1;
    while (isDigit(pathValue.charCodeAt(index))) {
      index += 1;
      hasDecimal = true;
    }
    ch = pathValue.charCodeAt(index);
  }
  if (ch === 101 || ch === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path.err = `${error}: ${invalidPathValue} at index ${index}, "${pathValue[index]}" invalid float exponent`;
      return;
    }
    index += 1;
    ch = pathValue.charCodeAt(index);
    if (ch === 43 || ch === 45) {
      index += 1;
    }
    if (index < max && isDigit(pathValue.charCodeAt(index))) {
      while (index < max && isDigit(pathValue.charCodeAt(index))) {
        index += 1;
      }
    } else {
      path.err = `${error}: ${invalidPathValue} at index ${index}, "${pathValue[index]}" invalid integer exponent`;
      return;
    }
  }
  path.index = index;
  path.param = +path.pathValue.slice(start, index);
}
function isSpace(ch) {
  const specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && specialSpaces.includes(ch);
}
function skipSpaces(path) {
  const { pathValue, max } = path;
  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {
    path.index += 1;
  }
}
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isArcCommand(code) {
  return (code | 32) === 97;
}
function scanSegment(path) {
  const { max, pathValue, index } = path;
  const cmdCode = pathValue.charCodeAt(index);
  const reqParams = paramsCount[pathValue[index].toLowerCase()];
  path.segmentStart = index;
  if (!isPathCommand(cmdCode)) {
    path.err = `${error}: ${invalidPathValue} "${pathValue[index]}" is not a path command`;
    return;
  }
  path.index += 1;
  skipSpaces(path);
  path.data = [];
  if (!reqParams) {
    finalizeSegment(path);
    return;
  }
  for (; ; ) {
    for (let i = reqParams; i > 0; i -= 1) {
      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);
      else scanParam(path);
      if (path.err.length) {
        return;
      }
      path.data.push(path.param);
      skipSpaces(path);
      if (path.index < max && pathValue.charCodeAt(path.index) === 44) {
        path.index += 1;
        skipSpaces(path);
      }
    }
    if (path.index >= path.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path.index))) {
      break;
    }
  }
  finalizeSegment(path);
}
function PathParser(pathString) {
  this.segments = [];
  this.pathValue = pathString;
  this.max = pathString.length;
  this.index = 0;
  this.param = 0;
  this.segmentStart = 0;
  this.data = [];
  this.err = "";
}
function parsePathString(pathInput) {
  if (isPathArray(pathInput)) {
    return clonePath(pathInput);
  }
  const path = new PathParser(pathInput);
  skipSpaces(path);
  while (path.index < path.max && !path.err.length) {
    scanSegment(path);
  }
  return path.err ? path.err : path.segments;
}
function pathToAbsolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return clonePath(pathInput);
  }
  const path = parsePathString(pathInput);
  let x = 0;
  let y = 0;
  let mx = 0;
  let my = 0;
  return path.map((segment) => {
    const values = segment.slice(1).map(Number);
    const [pathCommand] = segment;
    const absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      [x, y] = values;
      mx = x;
      my = y;
      return ["M", x, y];
    }
    let absoluteSegment = [];
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values[0],
            values[1],
            values[2],
            values[3],
            values[4],
            values[5] + x,
            values[6] + y
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values[0] + y];
          break;
        case "H":
          absoluteSegment = [absCommand, values[0] + x];
          break;
        default: {
          const absValues = values.map((n, j) => n + (j % 2 ? y : x));
          absoluteSegment = [absCommand, ...absValues];
        }
      }
    } else {
      absoluteSegment = [absCommand, ...values];
    }
    const segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x = mx;
        y = my;
        break;
      case "H":
        [, x] = absoluteSegment;
        break;
      case "V":
        [, y] = absoluteSegment;
        break;
      default:
        x = absoluteSegment[segLength - 2];
        y = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x;
          my = y;
        }
    }
    return absoluteSegment;
  });
}
function normalizeSegment(segment, params) {
  const [pathCommand] = segment;
  const {
    x1: px1,
    y1: py1,
    x2: px2,
    y2: py2
  } = params;
  const values = segment.slice(1).map(Number);
  let result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    const x1 = px1 * 2 - px2;
    const y1 = py1 * 2 - py2;
    params.x1 = x1;
    params.y1 = y1;
    result = ["C", x1, y1, ...values];
  } else if (pathCommand === "T") {
    const qx = px1 * 2 - params.qx;
    const qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy, ...values];
  } else if (pathCommand === "Q") {
    const [nqx, nqy] = values;
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}
var paramsParser = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  x: 0,
  y: 0,
  qx: null,
  qy: null
};
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return clonePath(pathInput);
  }
  const path = pathToAbsolute(pathInput);
  const params = { ...paramsParser };
  const ii = path.length;
  for (let i = 0; i < ii; i += 1) {
    path[i];
    path[i] = normalizeSegment(path[i], params);
    const segment = path[i];
    const seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path;
}
function rotateVector(x, y, rad) {
  const X = x * Math.cos(rad) - y * Math.sin(rad);
  const Y = x * Math.sin(rad) + y * Math.cos(rad);
  return { x: X, y: Y };
}
function arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {
  let x1 = X1;
  let y1 = Y1;
  let rx = RX;
  let ry = RY;
  let x2 = X2;
  let y2 = Y2;
  const d120 = Math.PI * 120 / 180;
  const rad = Math.PI / 180 * (+angle || 0);
  let res = [];
  let xy;
  let f1;
  let f2;
  let cx;
  let cy;
  if (!recursive) {
    xy = rotateVector(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotateVector(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    const x = (x1 - x2) / 2;
    const y = (y1 - y2) / 2;
    let h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx *= h;
      ry *= h;
    }
    const rx2 = rx * rx;
    const ry2 = ry * ry;
    const k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry * 10 ** 9 >> 0) / 10 ** 9);
    f2 = Math.asin(((y2 - cy) / ry * 10 ** 9 >> 0) / 10 ** 9);
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    if (f1 < 0) f1 = Math.PI * 2 + f1;
    if (f2 < 0) f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    [f1, f2, cx, cy] = recursive;
  }
  let df = f2 - f1;
  if (Math.abs(df) > d120) {
    const f2old = f2;
    const x2old = x2;
    const y2old = y2;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  const c1 = Math.cos(f1);
  const s1 = Math.sin(f1);
  const c2 = Math.cos(f2);
  const s2 = Math.sin(f2);
  const t = Math.tan(df / 4);
  const hx = 4 / 3 * rx * t;
  const hy = 4 / 3 * ry * t;
  const m1 = [x1, y1];
  const m2 = [x1 + hx * s1, y1 - hy * c1];
  const m3 = [x2 + hx * s2, y2 - hy * c2];
  const m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [...m2, ...m3, ...m4, ...res];
  }
  res = [...m2, ...m3, ...m4, ...res];
  const newres = [];
  for (let i = 0, ii = res.length; i < ii; i += 1) {
    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;
  }
  return newres;
}
function quadToCubic(x1, y1, qx, qy, x2, y2) {
  const r13 = 1 / 3;
  const r23 = 2 / 3;
  return [
    r13 * x1 + r23 * qx,
    // cpx1
    r13 * y1 + r23 * qy,
    // cpy1
    r13 * x2 + r23 * qx,
    // cpx2
    r13 * y2 + r23 * qy,
    // cpy2
    x2,
    y2
    // x,y
  ];
}
function midPoint(a, b, t) {
  const [ax, ay] = a;
  const [bx, by] = b;
  return [ax + (bx - ax) * t, ay + (by - ay) * t];
}
function distanceSquareRoot(a, b) {
  return Math.sqrt(
    (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])
  );
}
function segmentLineFactory(x1, y1, x2, y2, distance) {
  const length = distanceSquareRoot([x1, y1], [x2, y2]);
  let point = { x: 0, y: 0 };
  if (typeof distance === "number") {
    if (distance <= 0) {
      point = { x: x1, y: y1 };
    } else if (distance >= length) {
      point = { x: x2, y: y2 };
    } else {
      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);
      point = { x, y };
    }
  }
  return {
    length,
    point,
    min: {
      x: Math.min(x1, x2),
      y: Math.min(y1, y2)
    },
    max: {
      x: Math.max(x1, x2),
      y: Math.max(y1, y2)
    }
  };
}
function lineToCubic(x1, y1, x2, y2) {
  const t = 0.5;
  const p0 = [x1, y1];
  const p1 = [x2, y2];
  const p2 = midPoint(p0, p1, t);
  const p3 = midPoint(p1, p2, t);
  const p4 = midPoint(p2, p3, t);
  const p5 = midPoint(p3, p4, t);
  const p6 = midPoint(p4, p5, t);
  const seg1 = [...p0, ...p2, ...p4, ...p6, t];
  const cp1 = segmentLineFactory(...seg1).point;
  const seg2 = [...p6, ...p5, ...p3, ...p1, 0];
  const cp2 = segmentLineFactory(...seg2).point;
  return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];
}
function segmentToCubic(segment, params) {
  const [pathCommand] = segment;
  const values = segment.slice(1).map(Number);
  const [x, y] = values;
  let args;
  const {
    x1: px1,
    y1: py1,
    x: px,
    y: py
  } = params;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x;
      params.y = y;
      return segment;
    case "A":
      args = [px1, py1, ...values];
      return ["C", ...arcToCubic(...args)];
    case "Q":
      params.qx = x;
      params.qy = y;
      args = [px1, py1, ...values];
      return ["C", ...quadToCubic(...args)];
    case "L":
      return ["C", ...lineToCubic(px1, py1, x, y)];
    case "Z":
      return ["C", ...lineToCubic(px1, py1, px, py)];
  }
  return segment;
}
function pathToCurve(pathInput) {
  if (isCurveArray(pathInput)) {
    return clonePath(pathInput);
  }
  const path = normalizePath(pathInput);
  const params = { ...paramsParser };
  const allPathCommands = [];
  let pathCommand = "";
  let ii = path.length;
  for (let i = 0; i < ii; i += 1) {
    [pathCommand] = path[i];
    allPathCommands[i] = pathCommand;
    path[i] = segmentToCubic(path[i], params);
    fixArc(path, allPathCommands, i);
    ii = path.length;
    const segment = path[i];
    const seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path;
}
var defaultOptions = {
  origin: [0, 0, 0],
  round: 4
};
function roundPath(path, roundOption) {
  let { round } = defaultOptions;
  if (roundOption === "off" || round === "off") return clonePath(path);
  round = roundOption >= 0 ? roundOption : round;
  const pow = typeof round === "number" && round >= 1 ? 10 ** round : 1;
  return path.map((pi) => {
    const values = pi.slice(1).map(Number).map((n) => round ? Math.round(n * pow) / pow : Math.round(n));
    return [pi[0], ...values];
  });
}
function pathToString(path, round) {
  return roundPath(path, round).map((x) => x[0] + x.slice(1).join(" ")).join("");
}
function splitPath(pathInput) {
  const composite = [];
  let path;
  let pi = -1;
  pathInput.forEach((seg) => {
    if (seg[0] === "M") {
      path = [seg];
      pi += 1;
    } else {
      path = [...path, seg];
    }
    composite[pi] = path;
  });
  return composite;
}
function angleBetween(v0, v1) {
  const { x: v0x, y: v0y } = v0;
  const { x: v1x, y: v1y } = v1;
  const p = v0x * v1x + v0y * v1y;
  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));
  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  const angle = sign * Math.acos(p / n);
  return angle;
}
function getPointAtArcSegmentLength(x1, y1, RX, RY, angle, LAF, SF, x, y, t) {
  const {
    abs,
    sin,
    cos,
    sqrt,
    PI
  } = Math;
  let rx = abs(RX);
  let ry = abs(RY);
  const xRot = (angle % 360 + 360) % 360;
  const xRotRad = xRot * (PI / 180);
  if (x1 === x && y1 === y) {
    return { x: x1, y: y1 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x1, y1, x, y, t).point;
  }
  const dx = (x1 - x) / 2;
  const dy = (y1 - y) / 2;
  const transformedPoint = {
    x: cos(xRotRad) * dx + sin(xRotRad) * dy,
    y: -sin(xRotRad) * dx + cos(xRotRad) * dy
  };
  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 + transformedPoint.y ** 2 / ry ** 2;
  if (radiiCheck > 1) {
    rx *= sqrt(radiiCheck);
    ry *= sqrt(radiiCheck);
  }
  const cSquareNumerator = rx ** 2 * ry ** 2 - rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;
  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 + ry ** 2 * transformedPoint.x ** 2;
  let cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);
  const transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  const center = {
    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,
    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2
  };
  const startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  const endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  let sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI;
  }
  sweepAngle %= 2 * PI;
  const alpha = startAngle + sweepAngle * t;
  const ellipseComponentX = rx * cos(alpha);
  const ellipseComponentY = ry * sin(alpha);
  const point = {
    x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,
    y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y
  };
  return point;
}
function segmentArcFactory(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, distance) {
  const distanceIsNumber = typeof distance === "number";
  let x = X1;
  let y = Y1;
  let LENGTH = 0;
  let prev = [x, y, LENGTH];
  let cur = [x, y];
  let t = 0;
  let POINT = { x: 0, y: 0 };
  let POINTS = [{ x, y }];
  if (distanceIsNumber && distance <= 0) {
    POINT = { x, y };
  }
  const sampleSize = 300;
  for (let j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    ({ x, y } = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, t));
    POINTS = [...POINTS, { x, y }];
    LENGTH += distanceSquareRoot(cur, [x, y]);
    cur = [x, y];
    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {
      const dv = (LENGTH - distance) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance >= LENGTH) {
    POINT = { x: X2, y: Y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min(...POINTS.map((n) => n.x)),
      y: Math.min(...POINTS.map((n) => n.y))
    },
    max: {
      x: Math.max(...POINTS.map((n) => n.x)),
      y: Math.max(...POINTS.map((n) => n.y))
    }
  };
}
function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t) {
  const t1 = 1 - t;
  return {
    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x + t ** 3 * x2,
    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y + t ** 3 * y2
  };
}
function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance) {
  const distanceIsNumber = typeof distance === "number";
  let x = x1;
  let y = y1;
  let LENGTH = 0;
  let prev = [x, y, LENGTH];
  let cur = [x, y];
  let t = 0;
  let POINT = { x: 0, y: 0 };
  let POINTS = [{ x, y }];
  if (distanceIsNumber && distance <= 0) {
    POINT = { x, y };
  }
  const sampleSize = 300;
  for (let j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    ({ x, y } = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t));
    POINTS = [...POINTS, { x, y }];
    LENGTH += distanceSquareRoot(cur, [x, y]);
    cur = [x, y];
    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {
      const dv = (LENGTH - distance) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min(...POINTS.map((n) => n.x)),
      y: Math.min(...POINTS.map((n) => n.y))
    },
    max: {
      x: Math.max(...POINTS.map((n) => n.x)),
      y: Math.max(...POINTS.map((n) => n.y))
    }
  };
}
function getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t) {
  const t1 = 1 - t;
  return {
    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,
    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2
  };
}
function segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance) {
  const distanceIsNumber = typeof distance === "number";
  let x = x1;
  let y = y1;
  let LENGTH = 0;
  let prev = [x, y, LENGTH];
  let cur = [x, y];
  let t = 0;
  let POINT = { x: 0, y: 0 };
  let POINTS = [{ x, y }];
  if (distanceIsNumber && distance <= 0) {
    POINT = { x, y };
  }
  const sampleSize = 300;
  for (let j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    ({ x, y } = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t));
    POINTS = [...POINTS, { x, y }];
    LENGTH += distanceSquareRoot(cur, [x, y]);
    cur = [x, y];
    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {
      const dv = (LENGTH - distance) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x, y, LENGTH];
  }
  if (distanceIsNumber && distance >= LENGTH) {
    POINT = { x: x2, y: y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min(...POINTS.map((n) => n.x)),
      y: Math.min(...POINTS.map((n) => n.y))
    },
    max: {
      x: Math.max(...POINTS.map((n) => n.x)),
      y: Math.max(...POINTS.map((n) => n.y))
    }
  };
}
function pathLengthFactory(pathInput, distance) {
  const path = normalizePath(pathInput);
  const distanceIsNumber = typeof distance === "number";
  let isM;
  let data = [];
  let pathCommand;
  let x = 0;
  let y = 0;
  let mx = 0;
  let my = 0;
  let seg;
  let MIN = [];
  let MAX = [];
  let length = 0;
  let min = { x: 0, y: 0 };
  let max = min;
  let point = min;
  let POINT = min;
  let LENGTH = 0;
  for (let i = 0, ll = path.length; i < ll; i += 1) {
    seg = path[i];
    [pathCommand] = seg;
    isM = pathCommand === "M";
    data = !isM ? [x, y, ...seg.slice(1)] : data;
    if (isM) {
      [, mx, my] = seg;
      min = { x: mx, y: my };
      max = min;
      length = 0;
      if (distanceIsNumber && distance < 1e-3) {
        POINT = min;
      }
    } else if (pathCommand === "L") {
      ({
        length,
        min,
        max,
        point
      } = segmentLineFactory(...data, (distance || 0) - LENGTH));
    } else if (pathCommand === "A") {
      ({
        length,
        min,
        max,
        point
      } = segmentArcFactory(...data, (distance || 0) - LENGTH));
    } else if (pathCommand === "C") {
      ({
        length,
        min,
        max,
        point
      } = segmentCubicFactory(...data, (distance || 0) - LENGTH));
    } else if (pathCommand === "Q") {
      ({
        length,
        min,
        max,
        point
      } = segmentQuadFactory(...data, (distance || 0) - LENGTH));
    } else if (pathCommand === "Z") {
      data = [x, y, mx, my];
      ({
        length,
        min,
        max,
        point
      } = segmentLineFactory(...data, (distance || 0) - LENGTH));
    }
    if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {
      POINT = point;
    }
    MAX = [...MAX, max];
    MIN = [...MIN, min];
    LENGTH += length;
    [x, y] = pathCommand !== "Z" ? seg.slice(-2) : [mx, my];
  }
  if (distanceIsNumber && distance >= LENGTH) {
    POINT = { x, y };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min(...MIN.map((n) => n.x)),
      y: Math.min(...MIN.map((n) => n.y))
    },
    max: {
      x: Math.max(...MAX.map((n) => n.x)),
      y: Math.max(...MAX.map((n) => n.y))
    }
  };
}
function getTotalLength(pathInput) {
  return pathLengthFactory(pathInput).length;
}
function getPointAtLength(pathInput, distance) {
  return pathLengthFactory(pathInput, distance).point;
}
function polygonArea(polygon) {
  const n = polygon.length;
  let i = -1;
  let a;
  let b = polygon[n - 1];
  let area = 0;
  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }
  return area / 2;
}
function polygonLength(polygon) {
  return polygon.reduce((length, point, i) => {
    if (i) {
      return length + distanceSquareRoot(polygon[i - 1], point);
    }
    return 0;
  }, 0);
}
var epsilon = 1e-9;
function coords(a, b, l, v) {
  const points = [];
  for (let i = 0; i < l; i += 1) {
    points[i] = [];
    for (let j = 0; j < 2; j += 1) {
      points[i].push(((a[i][j] + (b[i][j] - a[i][j]) * v) * 1e3 >> 0) / 1e3);
    }
  }
  return points;
}
function onStartSVGMorph(tweenProp) {
  if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {
    KEC[tweenProp] = (elem, a, b, v) => {
      const path1 = a.polygon;
      const path2 = b.polygon;
      const len = path2.length;
      elem.setAttribute("d", v === 1 ? b.original : `M${coords(path1, path2, len, v).join("L")}Z`);
    };
  }
}
function exactPolygon(pathArray) {
  const polygon = [];
  const pathlen = pathArray.length;
  let segment = [];
  let pathCommand = "";
  if (!pathArray.length || pathArray[0][0] !== "M") {
    return false;
  }
  for (let i = 0; i < pathlen; i += 1) {
    segment = pathArray[i];
    [pathCommand] = segment;
    if (pathCommand === "M" && i || pathCommand === "Z") {
      break;
    } else if ("ML".includes(pathCommand)) {
      polygon.push([segment[1], segment[2]]);
    } else {
      return false;
    }
  }
  return pathlen ? { polygon } : false;
}
function approximatePolygon(parsed, maxLength) {
  const ringPath = splitPath(parsed)[0];
  const normalPath = normalizePath(ringPath);
  const pathLength = getTotalLength(normalPath);
  const polygon = [];
  let numPoints = 3;
  let point;
  if (maxLength && !Number.isNaN(maxLength) && +maxLength > 0) {
    numPoints = Math.max(numPoints, Math.ceil(pathLength / maxLength));
  }
  for (let i = 0; i < numPoints; i += 1) {
    point = getPointAtLength(normalPath, pathLength * i / numPoints);
    polygon.push([point.x, point.y]);
  }
  if (polygonArea(polygon) > 0) {
    polygon.reverse();
  }
  return {
    polygon,
    skipBisect: true
  };
}
function pathStringToPolygon(str, maxLength) {
  const parsed = normalizePath(str);
  return exactPolygon(parsed) || approximatePolygon(parsed, maxLength);
}
function rotatePolygon(polygon, vs) {
  const len = polygon.length;
  let min = Infinity;
  let bestOffset;
  let sumOfSquares = 0;
  let spliced;
  let d;
  let p;
  for (let offset = 0; offset < len; offset += 1) {
    sumOfSquares = 0;
    for (let i = 0; i < vs.length; i += 1) {
      p = vs[i];
      d = distanceSquareRoot(polygon[(offset + i) % len], p);
      sumOfSquares += d * d;
    }
    if (sumOfSquares < min) {
      min = sumOfSquares;
      bestOffset = offset;
    }
  }
  if (bestOffset) {
    spliced = polygon.splice(0, bestOffset);
    polygon.splice(polygon.length, 0, ...spliced);
  }
}
function addPoints(polygon, numPoints) {
  const desiredLength = polygon.length + numPoints;
  const step = polygonLength(polygon) / numPoints;
  let i = 0;
  let cursor = 0;
  let insertAt = step / 2;
  let a;
  let b;
  let segment;
  while (polygon.length < desiredLength) {
    a = polygon[i];
    b = polygon[(i + 1) % polygon.length];
    segment = distanceSquareRoot(a, b);
    if (insertAt <= cursor + segment) {
      polygon.splice(i + 1, 0, segment ? midPoint(a, b, (insertAt - cursor) / segment) : a.slice(0));
      insertAt += step;
    } else {
      cursor += segment;
      i += 1;
    }
  }
}
function bisect(polygon, maxSegmentLength = Infinity) {
  let a = [];
  let b = [];
  for (let i = 0; i < polygon.length; i += 1) {
    a = polygon[i];
    b = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];
    while (distanceSquareRoot(a, b) > maxSegmentLength) {
      b = midPoint(a, b, 0.5);
      polygon.splice(i + 1, 0, b);
    }
  }
}
function validPolygon(polygon) {
  return Array.isArray(polygon) && polygon.every((point) => Array.isArray(point) && point.length === 2 && !Number.isNaN(point[0]) && !Number.isNaN(point[1]));
}
function getPolygon(input, maxSegmentLength) {
  let skipBisect;
  let polygon;
  if (typeof input === "string") {
    const converted = pathStringToPolygon(input, maxSegmentLength);
    ({ polygon, skipBisect } = converted);
  } else if (!Array.isArray(input)) {
    throw Error(`${invalidPathValue}: ${input}`);
  }
  const points = [...polygon];
  if (!validPolygon(points)) {
    throw Error(`${invalidPathValue}: ${points}`);
  }
  if (points.length > 1 && distanceSquareRoot(points[0], points[points.length - 1]) < epsilon) {
    points.pop();
  }
  if (!skipBisect && maxSegmentLength && !Number.isNaN(maxSegmentLength) && +maxSegmentLength > 0) {
    bisect(points, maxSegmentLength);
  }
  return points;
}
function getInterpolationPoints(path1, path2, precision) {
  const morphPrecision = precision || defaultOptions$1.morphPrecision;
  const fromRing = getPolygon(path1, morphPrecision);
  const toRing = getPolygon(path2, morphPrecision);
  const diff = fromRing.length - toRing.length;
  addPoints(fromRing, diff < 0 ? diff * -1 : 0);
  addPoints(toRing, diff > 0 ? diff : 0);
  rotatePolygon(fromRing, toRing);
  return [roundPath(fromRing), roundPath(toRing)];
}
function getSVGMorph() {
  return this.element.getAttribute("d");
}
function prepareSVGMorph(_, value) {
  const pathObject = {};
  const pathReg = new RegExp("\\n", "ig");
  let elem = null;
  if (value instanceof SVGPathElement) {
    elem = value;
  } else if (/^\.|^#/.test(value)) {
    elem = selector(value);
  }
  if (typeof value === "object" && value.polygon) {
    return value;
  }
  if (elem && ["path", "glyph"].includes(elem.tagName)) {
    pathObject.original = elem.getAttribute("d").replace(pathReg, "");
  } else if (!elem && typeof value === "string") {
    pathObject.original = value.replace(pathReg, "");
  }
  return pathObject;
}
function crossCheckSVGMorph(prop) {
  if (this.valuesEnd[prop]) {
    const pathArray1 = this.valuesStart[prop].polygon;
    const pathArray2 = this.valuesEnd[prop].polygon;
    if (!pathArray1 || !pathArray2 || pathArray1.length !== pathArray2.length) {
      const p1 = this.valuesStart[prop].original;
      const p2 = this.valuesEnd[prop].original;
      const morphPrecision = this._morphPrecision ? parseInt(this._morphPrecision, 10) : defaultOptions$1.morphPrecision;
      const [path1, path2] = getInterpolationPoints(p1, p2, morphPrecision);
      this.valuesStart[prop].polygon = path1;
      this.valuesEnd[prop].polygon = path2;
    }
  }
}
var svgMorphFunctions = {
  prepareStart: getSVGMorph,
  prepareProperty: prepareSVGMorph,
  onStart: onStartSVGMorph,
  crossCheck: crossCheckSVGMorph
};
var SVGMorph = {
  component: "svgMorph",
  property: "path",
  defaultValue: [],
  Interpolate: coords,
  defaultOptions: { morphPrecision: 10 },
  functions: svgMorphFunctions,
  // Export utils to global for faster execution
  Util: {
    // component
    addPoints,
    bisect,
    getPolygon,
    validPolygon,
    getInterpolationPoints,
    pathStringToPolygon,
    distanceSquareRoot,
    midPoint,
    approximatePolygon,
    rotatePolygon,
    // svg-path-commander
    pathToString,
    pathToCurve,
    getTotalLength,
    getPointAtLength,
    polygonArea,
    roundPath
  }
};
var Components = {
  EssentialBoxModel: BoxModelEssential,
  ColorsProperties: colorProperties,
  HTMLAttributes: htmlAttributes,
  OpacityProperty,
  TextWriteProp: TextWrite,
  TransformFunctions,
  SVGDraw: SvgDrawProperty,
  SVGMorph
};
Object.keys(Components).forEach((component) => {
  const compOps = Components[component];
  Components[component] = new Animation(compOps);
});
var version = "2.2.4";
var Version = version;
var KUTE = {
  Animation,
  Components,
  // Tween Interface
  Tween,
  fromTo,
  to,
  // Tween Collection
  TweenCollection,
  allFromTo,
  allTo,
  // Tween Interface
  Objects,
  Util,
  Easing,
  CubicBezier,
  Render,
  Interpolate: interpolate,
  Process,
  Internals: internals,
  Selector: selector,
  Version
};
export {
  KUTE as default
};
//# sourceMappingURL=kute__js.js.map
